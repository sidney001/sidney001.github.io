{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"themes/maupassant/source/css/jquery.fancybox.css","path":"css/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/maupassant/source/css/style.scss","path":"css/style.scss","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/codeblock-resizer.js","path":"js/codeblock-resizer.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/fancybox.js","path":"js/fancybox.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/search.js","path":"js/search.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/share.js","path":"js/share.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/totop.js","path":"js/totop.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/smartresize.js","path":"js/smartresize.js","modified":1,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"ffda64d21f0d632cb700d54173df985b97635316","modified":1491549016333},{"_id":"themes/maupassant/.travis.yml","hash":"f8da426b97088e4caa5226cff219a5d95087961f","modified":1491645804536},{"_id":"themes/maupassant/_config.yml","hash":"23abb0afd1695325eaac09191939db5fab65863d","modified":1491734218704},{"_id":"themes/maupassant/LICENSE","hash":"0663fd3a7ea9fc4f4c634b4d73e2da426b536f86","modified":1491645804582},{"_id":"themes/maupassant/README.md","hash":"c8d1652807750b90edd683e299e7c7d5b2e60b83","modified":1491645804857},{"_id":"themes/maupassant/package.json","hash":"04ca87ea475f37841d3610fe5806feb8022416c3","modified":1491645806284},{"_id":"themes/maupassant/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1491645803482},{"_id":"themes/maupassant/.git/config","hash":"3dbf80769093e21ccab51f5f2b02a6d764498803","modified":1491645804393},{"_id":"themes/maupassant/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1491645798831},{"_id":"themes/maupassant/.git/index","hash":"1e1d36b4e9daee029b77ae974230c7d17bec4441","modified":1491654075506},{"_id":"themes/maupassant/.git/packed-refs","hash":"9bc7504ed27706a9c4a66d4fc7a4fb2ab289318d","modified":1491645802613},{"_id":"source/tags/index.md","hash":"d007063af25a451ceb179f455792de685ffd5a8d","modified":1473531052000},{"_id":"source/_posts/Hexo写作技巧(长期更新).md","hash":"548691697eadf7f3b43a50e89d77863c5ba2c176","modified":1491658052264},{"_id":"source/_posts/Hexo插件记录(长期更新).md","hash":"bccb2959fe1a42f659ae07a4fc9825a01c809959","modified":1491646263986},{"_id":"source/_posts/LeetCodeLintCode刷题之排序.md","hash":"5d43a11f7afba2aef46abbe4d58eb5cf7d36c7e9","modified":1491982850617},{"_id":"source/_posts/LeetCodeLintCode刷题之线性表.md","hash":"0ee89d105fbb4b30de0aa26e64cced434c4bd0a8","modified":1491931376187},{"_id":"source/_posts/Markdown语法.md","hash":"cdfd355de925251d3f61ca7b7ad6c4c436a556a5","modified":1491666359675},{"_id":"source/_posts/使用Hexo和GitHub-Pages搭建博客.md","hash":"567d05dc6ff3f1f682ca627d75c6c520a65bf2c1","modified":1491659151592},{"_id":"source/categories/index.md","hash":"1357cbf940b4606f975824709555c9e815484d7a","modified":1473531052000},{"_id":"source/_posts/hello-world.md","hash":"3c36230bfdfbbf919a213efb7f2e9fd4e64e5034","modified":1491206468272},{"_id":"themes/maupassant/languages/de-DE.yml","hash":"25d1d8cd8113045a7603c14af1ea1539fc6456ed","modified":1491645805185},{"_id":"themes/maupassant/languages/es-ES.yml","hash":"3cc9312fbdba4a8f8e8254804121e4724c719bcc","modified":1491645805302},{"_id":"themes/maupassant/languages/fr-FR.yml","hash":"3a50568f200b9c1258415b53727e42c6b6c7ea0b","modified":1491645805374},{"_id":"themes/maupassant/languages/en.yml","hash":"b0e69208b7efb549e0d716ade0f59ea684b20e67","modified":1491645805219},{"_id":"themes/maupassant/languages/ko.yml","hash":"a454bcec60113507bc1d593a699849822386c196","modified":1491645805446},{"_id":"themes/maupassant/languages/ru.yml","hash":"36edc014c6aaef367d58929089bf7915375e71a6","modified":1491645805529},{"_id":"themes/maupassant/languages/zh-CN.yml","hash":"41f7c09365cbd5ba1b8906191ee07bc75094185a","modified":1491645805602},{"_id":"themes/maupassant/languages/zh-TW.yml","hash":"46659764e31c7866af436d98d4fabb9da122037a","modified":1491645805675},{"_id":"themes/maupassant/layout/base-without-sidebar.jade","hash":"5901de9f23358158079a02c6470a491cf36ffbf2","modified":1491645806273},{"_id":"themes/maupassant/layout/index.jade","hash":"128250560fc0e7713dc032258b48d39444e45612","modified":1491645806276},{"_id":"themes/maupassant/layout/archive.jade","hash":"d70d1ed241b1a431a2434768d02bb2de03070f70","modified":1491645806271},{"_id":"themes/maupassant/layout/base.jade","hash":"513c2b66a327fc281917f4a5c567f93a39ecb96e","modified":1491645806275},{"_id":"themes/maupassant/layout/page.jade","hash":"1e98aa785073dc1bbfe70f2863bc19fe287483b9","modified":1491645806278},{"_id":"themes/maupassant/layout/post.jade","hash":"bc37fcb93493c885ea02b78b5055100d90887c30","modified":1491645806279},{"_id":"themes/maupassant/layout/timeline.jade","hash":"ee1e8e4e8fdf61c6d19f1f7fe31ab50ab1465a8d","modified":1491645806282},{"_id":"themes/maupassant/layout/single-column.jade","hash":"4be14ac93c154216e174fe0c4c05608c26f59c42","modified":1491645806281},{"_id":"themes/maupassant/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1491645798847},{"_id":"themes/maupassant/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1491645798848},{"_id":"themes/maupassant/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1491645798849},{"_id":"themes/maupassant/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1491645798851},{"_id":"themes/maupassant/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1491645798854},{"_id":"themes/maupassant/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1491645798855},{"_id":"themes/maupassant/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1491645798858},{"_id":"themes/maupassant/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1491645798857},{"_id":"themes/maupassant/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1491645798860},{"_id":"themes/maupassant/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1491645798862},{"_id":"themes/maupassant/.git/logs/HEAD","hash":"1ee9664d1d1c2bbe6a3a32c32122f0b9b7eba273","modified":1491645803901},{"_id":"themes/maupassant/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1491645798865},{"_id":"source/_posts/Hexo写作技巧(长期更新)/阅读全文.png","hash":"e663a425d6f5a0b158f830d72809ff10eaf81ed4","modified":1491642721522},{"_id":"themes/maupassant/layout/_partial/after_footer.jade","hash":"bbf701d5fbb88cc9995b0d19e81c2a6a391740d6","modified":1491645806106},{"_id":"themes/maupassant/layout/_partial/comments.jade","hash":"8ae38900c59c9c4852725cfcf67d185d2d78af39","modified":1491645806169},{"_id":"themes/maupassant/layout/_partial/footer.jade","hash":"87e096caac8e780c0894ef1844f59246f861bbe7","modified":1491645806205},{"_id":"themes/maupassant/layout/_partial/head.jade","hash":"c3658183101035df57822db7343f2f4fd58d55f3","modified":1491645806230},{"_id":"themes/maupassant/layout/_partial/helpers.jade","hash":"9e44f6d32f2449b4109c33118f8285fa2fc7b023","modified":1491645806250},{"_id":"themes/maupassant/layout/_partial/mathjax.jade","hash":"ac6e3a92bf18ab6bbd0e041b6796b295bae963ee","modified":1491645806251},{"_id":"themes/maupassant/layout/_partial/mathjax2.jade","hash":"234a792e64ba208fa97d2f99772ece23056a53ec","modified":1491645806253},{"_id":"themes/maupassant/layout/_partial/paginator.jade","hash":"03ad0c49ae6f8a999ae35b38d08e25775f51f52a","modified":1491645806254},{"_id":"themes/maupassant/layout/_partial/tag.jade","hash":"6145b483b271bba05ad1db7c039fe352a768215b","modified":1491645806257},{"_id":"themes/maupassant/layout/_partial/post_nav.jade","hash":"b11d9e6000449838b17f508429f29ffb60f53096","modified":1491645806256},{"_id":"themes/maupassant/layout/_partial/totop.jade","hash":"eb91a3baf9411188c7c8130f63a674f541ca9c81","modified":1491645806260},{"_id":"themes/maupassant/layout/_widget/category.jade","hash":"7707b4c718a935882ee986d0bb0078e50cdbea64","modified":1491645806262},{"_id":"themes/maupassant/layout/_widget/recent_comments.jade","hash":"0b9e78e7f20bc69690e05f2e0c956bded9058a84","modified":1491645806265},{"_id":"themes/maupassant/layout/_widget/links.jade","hash":"2a1dd6a0e2befd073e3347347994d8dcd2047879","modified":1491645806264},{"_id":"themes/maupassant/layout/_widget/recent_posts.jade","hash":"770b6c41cbf7969ed33adf87eec3be6f50a0911b","modified":1491645806267},{"_id":"themes/maupassant/layout/_widget/search.jade","hash":"c5301ca7f2ec24d790fd7f35f69f8fd8acbdb725","modified":1491645806269},{"_id":"themes/maupassant/layout/_widget/tag.jade","hash":"e9060ab84f925d5af93a75334b4ab17f9d056b5f","modified":1491660286566},{"_id":"themes/maupassant/source/css/jquery.fancybox.css","hash":"0d142e11e27e9de1a325c32369c42254101ddd34","modified":1491645806289},{"_id":"themes/maupassant/source/css/style.scss","hash":"3a00b275276847b054e71ea2eee47f548cd55dbf","modified":1491645806291},{"_id":"themes/maupassant/source/js/codeblock-resizer.js","hash":"c77270e684a60babc1abb7353e700ecdc5a66d30","modified":1491645806295},{"_id":"themes/maupassant/source/js/fancybox.js","hash":"8a993c1c4ad40789d2960b682cb2130382a0f26a","modified":1491645806296},{"_id":"themes/maupassant/source/js/search.js","hash":"dbda07a03e6edc73f1dc28a068c24a6037b97b56","modified":1491645806298},{"_id":"themes/maupassant/source/js/share.js","hash":"bb6880e2e8e187b576daf326476f09b0907fbe14","modified":1491645806299},{"_id":"themes/maupassant/source/js/totop.js","hash":"15de186b089c245fe60766d509b587919f05ff23","modified":1491645806303},{"_id":"themes/maupassant/source/js/smartresize.js","hash":"150ab1cad40d7ae081b0896b13f7d7cbac4e6338","modified":1491645806301},{"_id":"themes/maupassant/.git/objects/pack/pack-9b176454e62377d2defa3f4d12c470f9b9a04970.idx","hash":"8fc7f4fb5c955768a034a76136c894156bd608c7","modified":1491645802008},{"_id":"themes/maupassant/.git/refs/heads/master","hash":"35289176afdbca93bcb6d84081e07511070729e3","modified":1491645803578},{"_id":"themes/maupassant/.git/logs/refs/heads/master","hash":"1ee9664d1d1c2bbe6a3a32c32122f0b9b7eba273","modified":1491645804201},{"_id":"themes/maupassant/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1491645803394},{"_id":"themes/maupassant/.git/logs/refs/remotes/origin/HEAD","hash":"1ee9664d1d1c2bbe6a3a32c32122f0b9b7eba273","modified":1491645803364},{"_id":"themes/maupassant/.git/objects/pack/pack-9b176454e62377d2defa3f4d12c470f9b9a04970.pack","hash":"6cc2c111a73b40b4971fd0e912ecc1c9854fb204","modified":1491645802277}],"Category":[{"name":"hexo","_id":"cj23iflyx0004golax4zxxh54"},{"name":"刷题","_id":"cj23iflzd000egolahmq8zfc6"},{"name":"其它","_id":"cj23iflzh000mgola8blfr4d4"},{"name":"面试","parent":"cj23iflzd000egolahmq8zfc6","_id":"cj23iflzi000qgolajumua9yx"}],"Data":[],"Page":[{"title":"标签","type":"tags","date":"2016-09-07T05:42:07.000Z","comments":1,"_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ntype: \"tags\"\ndate: 2016-09-07 13:42:07\ncomments: true\n---\n","updated":"2016-09-10T18:10:52.000Z","path":"tags/index.html","layout":"page","_id":"cj23iflyq0000golagf1jiqtj","content":"","excerpt":"","more":""},{"title":"分类","date":"2016-09-08T08:18:41.000Z","type":"categories","comments":1,"_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ndate: 2016-09-08 16:18:41\ntype: categories\ncomments: true\n---\n","updated":"2016-09-10T18:10:52.000Z","path":"categories/index.html","layout":"page","_id":"cj23iflyu0002golaskxmfgz9","content":"","excerpt":"","more":""}],"Post":[{"title":"Hexo写作技巧(长期更新)","date":"2016-11-12T08:31:52.000Z","_content":"### 1.添加**阅读全文**来控制显示的内容\n在简介后面提供一个链接**阅读全文**来进入文章的详情页。\n![](Hexo写作技巧(长期更新）/阅读全文.png)\n\n这种方法可以根据文章的内容，自己在合适的位置添加`<!--more-->`标签，使用灵活，也是Hexo推荐的方法。","source":"_posts/Hexo写作技巧(长期更新).md","raw":"---\ntitle: Hexo写作技巧(长期更新)\ndate: 2016-11-12 16:31:52\ncategories:\n\t- hexo\ntags:\n\t- hexo\n\t- blog\n---\n### 1.添加**阅读全文**来控制显示的内容\n在简介后面提供一个链接**阅读全文**来进入文章的详情页。\n![](Hexo写作技巧(长期更新）/阅读全文.png)\n\n这种方法可以根据文章的内容，自己在合适的位置添加`<!--more-->`标签，使用灵活，也是Hexo推荐的方法。","slug":"Hexo写作技巧(长期更新)","published":1,"updated":"2017-04-08T13:27:32.264Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj23iflyr0001gola55jld4lp","content":"<h3 id=\"1-添加阅读全文来控制显示的内容\"><a href=\"#1-添加阅读全文来控制显示的内容\" class=\"headerlink\" title=\"1.添加阅读全文来控制显示的内容\"></a>1.添加<strong>阅读全文</strong>来控制显示的内容</h3><p>在简介后面提供一个链接<strong>阅读全文</strong>来进入文章的详情页。<br><img src=\"/2016/11/12/Hexo写作技巧(长期更新)/阅读全文.png\" alt=\"\"></p>\n<p>这种方法可以根据文章的内容，自己在合适的位置添加<code>&lt;!--more--&gt;</code>标签，使用灵活，也是Hexo推荐的方法。</p>\n","excerpt":"","more":"<h3 id=\"1-添加阅读全文来控制显示的内容\"><a href=\"#1-添加阅读全文来控制显示的内容\" class=\"headerlink\" title=\"1.添加阅读全文来控制显示的内容\"></a>1.添加<strong>阅读全文</strong>来控制显示的内容</h3><p>在简介后面提供一个链接<strong>阅读全文</strong>来进入文章的详情页。<br><img src=\"/2016/11/12/Hexo写作技巧(长期更新)/阅读全文.png\" alt=\"\"></p>\n<p>这种方法可以根据文章的内容，自己在合适的位置添加<code>&lt;!--more--&gt;</code>标签，使用灵活，也是Hexo推荐的方法。</p>\n"},{"title":"Hexo插件记录(长期更新)","date":"2016-11-12T10:31:52.000Z","_content":"# 1.使用**本地图片**\n hexo 中使用本地图片是件非常让人纠结的事情，在 markdown 里的图片地址似乎永远无法和最后生成的网页保持一致。解决方案：\n[hexo-asset-image](https://github.com/CodeFalling/hexo-asset-image)\n## 使用：\n首先确认 `_config.yml` 中有 `post_asset_folder:true` 。\n在 hexo 目录，执行\n`npm install https://github.com/CodeFalling/hexo-asset-image --save`\n假设在\n```shell\nMacGesture2-Publish\n├── apppicker.jpg\n├── logo.jpg\n└── rules.jpg\nMacGesture2-Publish.md\n```\n这样的目录结构（目录名和文章名一致），只要使用` ![logo](MacGesture2-Publish/logo.jpg)` 就可以插入图片。\n<!--more-->","source":"_posts/Hexo插件记录(长期更新).md","raw":"---\ntitle: Hexo插件记录(长期更新)\ndate: 2016-11-12 18:31:52\ncategories:\n\t- hexo\ntags:\n\t- hexo\n\t- blog\n---\n# 1.使用**本地图片**\n hexo 中使用本地图片是件非常让人纠结的事情，在 markdown 里的图片地址似乎永远无法和最后生成的网页保持一致。解决方案：\n[hexo-asset-image](https://github.com/CodeFalling/hexo-asset-image)\n## 使用：\n首先确认 `_config.yml` 中有 `post_asset_folder:true` 。\n在 hexo 目录，执行\n`npm install https://github.com/CodeFalling/hexo-asset-image --save`\n假设在\n```shell\nMacGesture2-Publish\n├── apppicker.jpg\n├── logo.jpg\n└── rules.jpg\nMacGesture2-Publish.md\n```\n这样的目录结构（目录名和文章名一致），只要使用` ![logo](MacGesture2-Publish/logo.jpg)` 就可以插入图片。\n<!--more-->","slug":"Hexo插件记录(长期更新)","published":1,"updated":"2017-04-08T10:11:03.986Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj23iflyw0003gola7ydzv7dh","content":"<h1 id=\"1-使用本地图片\"><a href=\"#1-使用本地图片\" class=\"headerlink\" title=\"1.使用本地图片\"></a>1.使用<strong>本地图片</strong></h1><p> hexo 中使用本地图片是件非常让人纠结的事情，在 markdown 里的图片地址似乎永远无法和最后生成的网页保持一致。解决方案：<br><a href=\"https://github.com/CodeFalling/hexo-asset-image\" target=\"_blank\" rel=\"external\">hexo-asset-image</a></p>\n<h2 id=\"使用：\"><a href=\"#使用：\" class=\"headerlink\" title=\"使用：\"></a>使用：</h2><p>首先确认 <code>_config.yml</code> 中有 <code>post_asset_folder:true</code> 。<br>在 hexo 目录，执行<br><code>npm install https://github.com/CodeFalling/hexo-asset-image --save</code><br>假设在<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">MacGesture2-Publish</div><div class=\"line\">├── apppicker.jpg</div><div class=\"line\">├── logo.jpg</div><div class=\"line\">└── rules.jpg</div><div class=\"line\">MacGesture2-Publish.md</div></pre></td></tr></table></figure></p>\n<p>这样的目录结构（目录名和文章名一致），只要使用<code>![logo](MacGesture2-Publish/logo.jpg)</code> 就可以插入图片。<br><a id=\"more\"></a></p>\n","excerpt":"<h1 id=\"1-使用本地图片\"><a href=\"#1-使用本地图片\" class=\"headerlink\" title=\"1.使用本地图片\"></a>1.使用<strong>本地图片</strong></h1><p> hexo 中使用本地图片是件非常让人纠结的事情，在 markdown 里的图片地址似乎永远无法和最后生成的网页保持一致。解决方案：<br><a href=\"https://github.com/CodeFalling/hexo-asset-image\">hexo-asset-image</a></p>\n<h2 id=\"使用：\"><a href=\"#使用：\" class=\"headerlink\" title=\"使用：\"></a>使用：</h2><p>首先确认 <code>_config.yml</code> 中有 <code>post_asset_folder:true</code> 。<br>在 hexo 目录，执行<br><code>npm install https://github.com/CodeFalling/hexo-asset-image --save</code><br>假设在<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">MacGesture2-Publish</div><div class=\"line\">├── apppicker.jpg</div><div class=\"line\">├── logo.jpg</div><div class=\"line\">└── rules.jpg</div><div class=\"line\">MacGesture2-Publish.md</div></pre></td></tr></table></figure></p>\n<p>这样的目录结构（目录名和文章名一致），只要使用<code>![logo](MacGesture2-Publish/logo.jpg)</code> 就可以插入图片。<br></p>","more":"<p></p>"},{"title":"LeetCode/LintCode刷题之线性表","date":"2017-03-17T08:50:03.000Z","comments":1,"mathjax":true,"_content":"\n\n#线性表\n\n## Longest Consecutive Sequence\n- leetcode: [Longest Consecutive Sequence | LeetCode OJ](https://leetcode.com/problems/longest-consecutive-sequence/)\n- lintcode: [(124) Longest Consecutive Sequence](http://www.lintcode.com/en/problem/longest-consecutive-sequence/)\n\n\n### Problem Statement\n\nGiven an unsorted array of integers, find the length of the longest\nconsecutive elements sequence.\n\n#### Example\n\nGiven `[100, 4, 200, 1, 3, 2]`,\nThe longest consecutive elements sequence is `[1, 2, 3, 4]`. Return its\nlength: `4`.\n\n#### Clarification\n\nYour algorithm should run in O(_n_) complexity.\n\n\n### 题解\n\n首先看题要求，时间复杂度为 $O(n)$, 如果排序，基于比较的实现为 $O(n \\log n)$, 基数排序需要数据有特征。故排序无法达到复杂度要求。接下来可以联想空间换时间的做法，其中以哈希表为代表。这个题要求返回最长连续序列，不要求有序，非常符合哈希表的用法。**由于给定一个数其连续的数要么比它小1，要么大1，那么我们只需往左往右搜索知道在数组中找不到数为止。**结合哈希表查找为 $O(1)$ 的特性即可满足要求。用一个哈希表 ```unordered_map<int, bool> used``` 记录每个元素是否使用，对每个元素，以该元素为中心，往左右扩张，直到不连续为止，记录下贵长的长度。\n\n详细说明：你看到[100, 4, 200, 1, 3, 2]这个数组，首先你会看99或者101在不在这个数组里，发现数组没这两个数，那么100组成的连续序列长度仅为1。接着会看5或者3在不在数组里，会发现3存在，5不存在；紧接着会看2在不在....直到发现0不在。从而得到4组成的最长序列为4。\n总结一下会发现，我们在判断某个数的连续序列时，会分别往减小和增大的方向找下一个连续数在不在数组中。然后把两个方向的长度加起来即为包含该数的一个连续序列。需要注意的是，当前数的长度计数只需要出现在一个方向的查找中计算即可，否则就重复了。要找一个数是不是在数组中，不可能用遍历的方法实现，这样时间复杂度就超过$O(n)$了。而要降低时间复杂度，一个经典的方案就是空间换时间。用增加空间复杂度的方法来换取时间复杂度的降低。所以我们可以先对数组进行一次预处理，生成一份包含数组元素的哈希表。这样在求解某个数字在不在数组时就可以得到O(1)的时间复杂度。\n\n\n### C++\n```C++\nclass Solution {\npublic:\n    int longestConsecutive(vector<int>& nums) {\n        unordered_map<int, bool> used;\n        for (auto i : nums) used[i] = false; //遍历容器bector里的每一个元素,设为false\n        //for (auto i=1;i<5;i++) cout<<used[i];\n        int longest = 0;\n        for (auto i : nums) {\n            if (used[i]) continue; //防止array中有重复integar，continue跳出本次循环\n            int length = 1;\n            used[i] = true;\n            for (int j = i + 1; used.find(j) != used.end(); ++j) {\n            //用find函数来定位数据出现位置，它返回的一个迭代器\n            //如果map中没有要查找的数据，它返回的迭代器等于end函数返回的迭代器\n                used[j] = true;\n                ++length;\n                }\n            for (int j = i - 1; used.find(j) != used.end(); --j) {\n                used[j] = true;\n                ++length;\n            }\n            longest = max(longest, length);\n        }\n        return longest;\n    }\n};\n```\n### 复杂度分析\n时间复杂度和空间复杂度均为 $O(n)$.\n\n参考：map用法：http://blog.sina.com.cn/s/blog_59b6af690100xy0z.html\n\n## Two Sum\n\nTags: Array, Hash Table, Easy\n\n## Question\n\n- leetcode: [Two Sum](https://leetcode.com/problems/two-sum/)\n- lintcode: [Two Sum](http://www.lintcode.com/en/problem/two-sum/)\n\n### Problem Statement\n\nGiven an array of integers, return **indices** of the two numbers such that\nthey add up to a specific target.\n\nYou may assume that each input would have **_exactly_** one solution, and you\nmay not use the _same_ element twice.\n\n**Example:**  \n    \n    Given nums = [2, 7, 11, 15], target = 9,\n    \n    Because nums[**0**] + nums[**1**] = 2 + 7 = 9,\n    return [**0**, **1**].\n\n\n\n### 题解 - 哈希表\n\n找两数之和是否为`target`, 如果是找数组中一个值为`target`该多好啊！遍历一次就知道了, 难道要将数组中所有元素的两两组合都求出来与`target`比较吗？时间复杂度显然为 $O(n^2)$, 显然不符题目要求。找一个数时直接遍历即可，那么可不可以将两个数之和转换为找一个数呢？我们先来看看两数之和为`target`所对应的判断条件—— $x_i + x_j = target$, 可进一步转化为 $x_i = target - x_j$, 其中 $i$ 和 $j$ 为数组中的下标。一段神奇的数学推理就**将找两数之和转化为了找一个数是否在数组中了**！\n基本思路有了，现在就来看看怎么实现，显然我们需要额外的空间(也就是哈希表)来保存已经处理过的 $x_j$(**注意这里并不能先初始化哈希表，否则无法排除两个相同的元素相加为 target 的情况**), 如果不满足等式条件，那么我们就往后遍历，并把之前的元素加入到哈希表中，如果`target`减去当前索引后的值在哈希表中找到了，那么就将哈希表中相应的索引返回，大功告成！\n\n**万能的哈希！！！！**\n\n### C++\n```C++\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        vector<int> result;\n        const int length = nums.size();\n        if (!length) {\n            return result;\n        }\n    // first value, second index\n    unordered_map<int, int> hash(length);\n    for (int i = 0; i != length; ++i) {\n        if (hash.find(target - nums[i]) != hash.end()) {\n            result.push_back(hash[target - nums[i]]);//index比i要小\n            result.push_back(i);//题目要求index小的在前面\n            return result;\n        } else {\n            hash[nums[i]] = i;//放入哈希表中 i=0先放入哈希表\n        }\n    }\n    return result;\n    }\n};\n```\n### 复杂度分析\n哈希表⽤了和数组等⻓的空间，空间复杂度为$O(n)$, 遍历⼀次数组，时间复杂度为$O(n)$.\n\n参考：http://www.jiuzhang.com/solutions/2-sum/\n\n## 3 Sum\n\n## Question\n\n- leetcode: [3Sum | LeetCode OJ](https://leetcode.com/problems/3sum/)\n- lintcode: [(57) 3 Sum](http://www.lintcode.com/en/problem/3sum/)\n\n### Problem Statement\n\nGiven an array _S_ of _n_ integers, are there elements _a_, _b_, _c_ in _S_\nsuch that _a_ + _b_ + _c_ = 0? Find all unique triplets in the array which\ngives the sum of zero.\n\n#### Note:\n\nThe solution set must not contain duplicate triplets.\n    \n    For example, given array S = [-1, 0, 1, 2, -1, -4],\n    \n    A solution set is:\n    [\n      [-1, 0, 1],\n      [-1, -1, 2]\n    ]\n\n\n\n### 题解1 - 排序 + 哈希表 + 2 Sum\n\n相比之前的 2 Sum, 3 Sum 又多加了一个数，按照之前 2 Sum 的分解为『1 Sum + 1 Sum』的思路，我们同样可以将 3 Sum 分解为『1 Sum + 2 Sum』的问题，具体就是首先对原数组排序，排序后选出第一个元素，随后在剩下的元素中使用 2 Sum 的解法。\n### C++\n```c++\nclass Solution {\npublic:\n    vector<vector<int>> threeSum(vector<int>& nums) {\n        vector<vector<int> > result;\n        if (nums.size() < 3) return result;\n        int ans = 0;\n        sort(nums.begin(), nums.end());\n        const int length = nums.size();\n        //for(i = 0; i < nums.size() - 2; ++i){ //最后2个没有可能性\n        for(int i = 0; i < nums.size() - 2; ++i){\n            if (i > 0 && nums[i] == nums[i - 1])\n                continue; //重复数字跳出循环\n            int target = 0 - nums[i];\n            unordered_map<int, int> hash(length);// first value, second index\n            for(int j = i + 1; j < nums.size(); ++j){\n                if (hash.find(target - nums[j]) != hash.end()) {\n                    result.push_back({nums[i], target - nums[j], nums[j]});\n                    //result.push_front(nums[j]);//题目要求index小的在前面\n                    //result.push_front(target - nums[j]);//index比j的index小\n                    //return result;\n                } else {\n                    hash[nums[j]] = j;\n                }\n            }\n  \n        }\n        result.erase(unique(result.begin(), result.end()), result.end());\n        return result;\n    }\n};\n//error:[0,0,0,0] Output:[[0,0,0],[0,0,0]] 解决：加入erase删除重复\n```\n或：先排序，然后左右夹逼，复杂度 $O(n^2)$。\n这个方法可以推广到 k-sum，先排序，然后敬 k − 2 次悟环，在偎内层悟环左右夹逼，肘间复杂 度是 $O(max\\{n log n, n^{k−1}\\})$。\n\n\n### C++\n```c++\n\n```\n\n\n","source":"_posts/LeetCodeLintCode刷题之线性表.md","raw":"---\ntitle: LeetCode/LintCode刷题之线性表\ndate: 2017-3-17 16:50:03\ncomments: true\nmathjax: true\ncategories:\n\t- 刷题\n\t- 面试\ntags: \n\t- C++\n\t- Python\n---\n\n\n#线性表\n\n## Longest Consecutive Sequence\n- leetcode: [Longest Consecutive Sequence | LeetCode OJ](https://leetcode.com/problems/longest-consecutive-sequence/)\n- lintcode: [(124) Longest Consecutive Sequence](http://www.lintcode.com/en/problem/longest-consecutive-sequence/)\n\n\n### Problem Statement\n\nGiven an unsorted array of integers, find the length of the longest\nconsecutive elements sequence.\n\n#### Example\n\nGiven `[100, 4, 200, 1, 3, 2]`,\nThe longest consecutive elements sequence is `[1, 2, 3, 4]`. Return its\nlength: `4`.\n\n#### Clarification\n\nYour algorithm should run in O(_n_) complexity.\n\n\n### 题解\n\n首先看题要求，时间复杂度为 $O(n)$, 如果排序，基于比较的实现为 $O(n \\log n)$, 基数排序需要数据有特征。故排序无法达到复杂度要求。接下来可以联想空间换时间的做法，其中以哈希表为代表。这个题要求返回最长连续序列，不要求有序，非常符合哈希表的用法。**由于给定一个数其连续的数要么比它小1，要么大1，那么我们只需往左往右搜索知道在数组中找不到数为止。**结合哈希表查找为 $O(1)$ 的特性即可满足要求。用一个哈希表 ```unordered_map<int, bool> used``` 记录每个元素是否使用，对每个元素，以该元素为中心，往左右扩张，直到不连续为止，记录下贵长的长度。\n\n详细说明：你看到[100, 4, 200, 1, 3, 2]这个数组，首先你会看99或者101在不在这个数组里，发现数组没这两个数，那么100组成的连续序列长度仅为1。接着会看5或者3在不在数组里，会发现3存在，5不存在；紧接着会看2在不在....直到发现0不在。从而得到4组成的最长序列为4。\n总结一下会发现，我们在判断某个数的连续序列时，会分别往减小和增大的方向找下一个连续数在不在数组中。然后把两个方向的长度加起来即为包含该数的一个连续序列。需要注意的是，当前数的长度计数只需要出现在一个方向的查找中计算即可，否则就重复了。要找一个数是不是在数组中，不可能用遍历的方法实现，这样时间复杂度就超过$O(n)$了。而要降低时间复杂度，一个经典的方案就是空间换时间。用增加空间复杂度的方法来换取时间复杂度的降低。所以我们可以先对数组进行一次预处理，生成一份包含数组元素的哈希表。这样在求解某个数字在不在数组时就可以得到O(1)的时间复杂度。\n\n\n### C++\n```C++\nclass Solution {\npublic:\n    int longestConsecutive(vector<int>& nums) {\n        unordered_map<int, bool> used;\n        for (auto i : nums) used[i] = false; //遍历容器bector里的每一个元素,设为false\n        //for (auto i=1;i<5;i++) cout<<used[i];\n        int longest = 0;\n        for (auto i : nums) {\n            if (used[i]) continue; //防止array中有重复integar，continue跳出本次循环\n            int length = 1;\n            used[i] = true;\n            for (int j = i + 1; used.find(j) != used.end(); ++j) {\n            //用find函数来定位数据出现位置，它返回的一个迭代器\n            //如果map中没有要查找的数据，它返回的迭代器等于end函数返回的迭代器\n                used[j] = true;\n                ++length;\n                }\n            for (int j = i - 1; used.find(j) != used.end(); --j) {\n                used[j] = true;\n                ++length;\n            }\n            longest = max(longest, length);\n        }\n        return longest;\n    }\n};\n```\n### 复杂度分析\n时间复杂度和空间复杂度均为 $O(n)$.\n\n参考：map用法：http://blog.sina.com.cn/s/blog_59b6af690100xy0z.html\n\n## Two Sum\n\nTags: Array, Hash Table, Easy\n\n## Question\n\n- leetcode: [Two Sum](https://leetcode.com/problems/two-sum/)\n- lintcode: [Two Sum](http://www.lintcode.com/en/problem/two-sum/)\n\n### Problem Statement\n\nGiven an array of integers, return **indices** of the two numbers such that\nthey add up to a specific target.\n\nYou may assume that each input would have **_exactly_** one solution, and you\nmay not use the _same_ element twice.\n\n**Example:**  \n    \n    Given nums = [2, 7, 11, 15], target = 9,\n    \n    Because nums[**0**] + nums[**1**] = 2 + 7 = 9,\n    return [**0**, **1**].\n\n\n\n### 题解 - 哈希表\n\n找两数之和是否为`target`, 如果是找数组中一个值为`target`该多好啊！遍历一次就知道了, 难道要将数组中所有元素的两两组合都求出来与`target`比较吗？时间复杂度显然为 $O(n^2)$, 显然不符题目要求。找一个数时直接遍历即可，那么可不可以将两个数之和转换为找一个数呢？我们先来看看两数之和为`target`所对应的判断条件—— $x_i + x_j = target$, 可进一步转化为 $x_i = target - x_j$, 其中 $i$ 和 $j$ 为数组中的下标。一段神奇的数学推理就**将找两数之和转化为了找一个数是否在数组中了**！\n基本思路有了，现在就来看看怎么实现，显然我们需要额外的空间(也就是哈希表)来保存已经处理过的 $x_j$(**注意这里并不能先初始化哈希表，否则无法排除两个相同的元素相加为 target 的情况**), 如果不满足等式条件，那么我们就往后遍历，并把之前的元素加入到哈希表中，如果`target`减去当前索引后的值在哈希表中找到了，那么就将哈希表中相应的索引返回，大功告成！\n\n**万能的哈希！！！！**\n\n### C++\n```C++\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        vector<int> result;\n        const int length = nums.size();\n        if (!length) {\n            return result;\n        }\n    // first value, second index\n    unordered_map<int, int> hash(length);\n    for (int i = 0; i != length; ++i) {\n        if (hash.find(target - nums[i]) != hash.end()) {\n            result.push_back(hash[target - nums[i]]);//index比i要小\n            result.push_back(i);//题目要求index小的在前面\n            return result;\n        } else {\n            hash[nums[i]] = i;//放入哈希表中 i=0先放入哈希表\n        }\n    }\n    return result;\n    }\n};\n```\n### 复杂度分析\n哈希表⽤了和数组等⻓的空间，空间复杂度为$O(n)$, 遍历⼀次数组，时间复杂度为$O(n)$.\n\n参考：http://www.jiuzhang.com/solutions/2-sum/\n\n## 3 Sum\n\n## Question\n\n- leetcode: [3Sum | LeetCode OJ](https://leetcode.com/problems/3sum/)\n- lintcode: [(57) 3 Sum](http://www.lintcode.com/en/problem/3sum/)\n\n### Problem Statement\n\nGiven an array _S_ of _n_ integers, are there elements _a_, _b_, _c_ in _S_\nsuch that _a_ + _b_ + _c_ = 0? Find all unique triplets in the array which\ngives the sum of zero.\n\n#### Note:\n\nThe solution set must not contain duplicate triplets.\n    \n    For example, given array S = [-1, 0, 1, 2, -1, -4],\n    \n    A solution set is:\n    [\n      [-1, 0, 1],\n      [-1, -1, 2]\n    ]\n\n\n\n### 题解1 - 排序 + 哈希表 + 2 Sum\n\n相比之前的 2 Sum, 3 Sum 又多加了一个数，按照之前 2 Sum 的分解为『1 Sum + 1 Sum』的思路，我们同样可以将 3 Sum 分解为『1 Sum + 2 Sum』的问题，具体就是首先对原数组排序，排序后选出第一个元素，随后在剩下的元素中使用 2 Sum 的解法。\n### C++\n```c++\nclass Solution {\npublic:\n    vector<vector<int>> threeSum(vector<int>& nums) {\n        vector<vector<int> > result;\n        if (nums.size() < 3) return result;\n        int ans = 0;\n        sort(nums.begin(), nums.end());\n        const int length = nums.size();\n        //for(i = 0; i < nums.size() - 2; ++i){ //最后2个没有可能性\n        for(int i = 0; i < nums.size() - 2; ++i){\n            if (i > 0 && nums[i] == nums[i - 1])\n                continue; //重复数字跳出循环\n            int target = 0 - nums[i];\n            unordered_map<int, int> hash(length);// first value, second index\n            for(int j = i + 1; j < nums.size(); ++j){\n                if (hash.find(target - nums[j]) != hash.end()) {\n                    result.push_back({nums[i], target - nums[j], nums[j]});\n                    //result.push_front(nums[j]);//题目要求index小的在前面\n                    //result.push_front(target - nums[j]);//index比j的index小\n                    //return result;\n                } else {\n                    hash[nums[j]] = j;\n                }\n            }\n  \n        }\n        result.erase(unique(result.begin(), result.end()), result.end());\n        return result;\n    }\n};\n//error:[0,0,0,0] Output:[[0,0,0],[0,0,0]] 解决：加入erase删除重复\n```\n或：先排序，然后左右夹逼，复杂度 $O(n^2)$。\n这个方法可以推广到 k-sum，先排序，然后敬 k − 2 次悟环，在偎内层悟环左右夹逼，肘间复杂 度是 $O(max\\{n log n, n^{k−1}\\})$。\n\n\n### C++\n```c++\n\n```\n\n\n","slug":"LeetCodeLintCode刷题之线性表","published":1,"updated":"2017-04-11T17:22:56.187Z","layout":"post","photos":[],"link":"","_id":"cj23iflz10006gola7laq0nhx","content":"<p>#线性表</p>\n<h2 id=\"Longest-Consecutive-Sequence\"><a href=\"#Longest-Consecutive-Sequence\" class=\"headerlink\" title=\"Longest Consecutive Sequence\"></a>Longest Consecutive Sequence</h2><ul>\n<li>leetcode: <a href=\"https://leetcode.com/problems/longest-consecutive-sequence/\" target=\"_blank\" rel=\"external\">Longest Consecutive Sequence | LeetCode OJ</a></li>\n<li>lintcode: <a href=\"http://www.lintcode.com/en/problem/longest-consecutive-sequence/\" target=\"_blank\" rel=\"external\">(124) Longest Consecutive Sequence</a></li>\n</ul>\n<h3 id=\"Problem-Statement\"><a href=\"#Problem-Statement\" class=\"headerlink\" title=\"Problem Statement\"></a>Problem Statement</h3><p>Given an unsorted array of integers, find the length of the longest<br>consecutive elements sequence.</p>\n<h4 id=\"Example\"><a href=\"#Example\" class=\"headerlink\" title=\"Example\"></a>Example</h4><p>Given <code>[100, 4, 200, 1, 3, 2]</code>,<br>The longest consecutive elements sequence is <code>[1, 2, 3, 4]</code>. Return its<br>length: <code>4</code>.</p>\n<h4 id=\"Clarification\"><a href=\"#Clarification\" class=\"headerlink\" title=\"Clarification\"></a>Clarification</h4><p>Your algorithm should run in O(<em>n</em>) complexity.</p>\n<h3 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h3><p>首先看题要求，时间复杂度为 $O(n)$, 如果排序，基于比较的实现为 $O(n \\log n)$, 基数排序需要数据有特征。故排序无法达到复杂度要求。接下来可以联想空间换时间的做法，其中以哈希表为代表。这个题要求返回最长连续序列，不要求有序，非常符合哈希表的用法。<strong>由于给定一个数其连续的数要么比它小1，要么大1，那么我们只需往左往右搜索知道在数组中找不到数为止。</strong>结合哈希表查找为 $O(1)$ 的特性即可满足要求。用一个哈希表 <figure class=\"highlight plain\"><figcaption><span>bool> used``` 记录每个元素是否使用，对每个元素，以该元素为中心，往左右扩张，直到不连续为止，记录下贵长的长度。</span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">详细说明：你看到[100, 4, 200, 1, 3, 2]这个数组，首先你会看99或者101在不在这个数组里，发现数组没这两个数，那么100组成的连续序列长度仅为1。接着会看5或者3在不在数组里，会发现3存在，5不存在；紧接着会看2在不在....直到发现0不在。从而得到4组成的最长序列为4。</div><div class=\"line\">总结一下会发现，我们在判断某个数的连续序列时，会分别往减小和增大的方向找下一个连续数在不在数组中。然后把两个方向的长度加起来即为包含该数的一个连续序列。需要注意的是，当前数的长度计数只需要出现在一个方向的查找中计算即可，否则就重复了。要找一个数是不是在数组中，不可能用遍历的方法实现，这样时间复杂度就超过$O(n)$了。而要降低时间复杂度，一个经典的方案就是空间换时间。用增加空间复杂度的方法来换取时间复杂度的降低。所以我们可以先对数组进行一次预处理，生成一份包含数组元素的哈希表。这样在求解某个数字在不在数组时就可以得到O(1)的时间复杂度。</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">### C++</div><div class=\"line\">```C++</div><div class=\"line\">class Solution &#123;</div><div class=\"line\">public:</div><div class=\"line\">    int longestConsecutive(vector&lt;int&gt;&amp; nums) &#123;</div><div class=\"line\">        unordered_map&lt;int, bool&gt; used;</div><div class=\"line\">        for (auto i : nums) used[i] = false; //遍历容器bector里的每一个元素,设为false</div><div class=\"line\">        //for (auto i=1;i&lt;5;i++) cout&lt;&lt;used[i];</div><div class=\"line\">        int longest = 0;</div><div class=\"line\">        for (auto i : nums) &#123;</div><div class=\"line\">            if (used[i]) continue; //防止array中有重复integar，continue跳出本次循环</div><div class=\"line\">            int length = 1;</div><div class=\"line\">            used[i] = true;</div><div class=\"line\">            for (int j = i + 1; used.find(j) != used.end(); ++j) &#123;</div><div class=\"line\">            //用find函数来定位数据出现位置，它返回的一个迭代器</div><div class=\"line\">            //如果map中没有要查找的数据，它返回的迭代器等于end函数返回的迭代器</div><div class=\"line\">                used[j] = true;</div><div class=\"line\">                ++length;</div><div class=\"line\">                &#125;</div><div class=\"line\">            for (int j = i - 1; used.find(j) != used.end(); --j) &#123;</div><div class=\"line\">                used[j] = true;</div><div class=\"line\">                ++length;</div><div class=\"line\">            &#125;</div><div class=\"line\">            longest = max(longest, length);</div><div class=\"line\">        &#125;</div><div class=\"line\">        return longest;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<h3 id=\"复杂度分析\"><a href=\"#复杂度分析\" class=\"headerlink\" title=\"复杂度分析\"></a>复杂度分析</h3><p>时间复杂度和空间复杂度均为 $O(n)$.</p>\n<p>参考：map用法：<a href=\"http://blog.sina.com.cn/s/blog_59b6af690100xy0z.html\" target=\"_blank\" rel=\"external\">http://blog.sina.com.cn/s/blog_59b6af690100xy0z.html</a></p>\n<h2 id=\"Two-Sum\"><a href=\"#Two-Sum\" class=\"headerlink\" title=\"Two Sum\"></a>Two Sum</h2><p>Tags: Array, Hash Table, Easy</p>\n<h2 id=\"Question\"><a href=\"#Question\" class=\"headerlink\" title=\"Question\"></a>Question</h2><ul>\n<li>leetcode: <a href=\"https://leetcode.com/problems/two-sum/\" target=\"_blank\" rel=\"external\">Two Sum</a></li>\n<li>lintcode: <a href=\"http://www.lintcode.com/en/problem/two-sum/\" target=\"_blank\" rel=\"external\">Two Sum</a></li>\n</ul>\n<h3 id=\"Problem-Statement-1\"><a href=\"#Problem-Statement-1\" class=\"headerlink\" title=\"Problem Statement\"></a>Problem Statement</h3><p>Given an array of integers, return <strong>indices</strong> of the two numbers such that<br>they add up to a specific target.</p>\n<p>You may assume that each input would have <strong><em>exactly</em></strong> one solution, and you<br>may not use the <em>same</em> element twice.</p>\n<p><strong>Example:</strong>  </p>\n<pre><code>Given nums = [2, 7, 11, 15], target = 9,\n\nBecause nums[**0**] + nums[**1**] = 2 + 7 = 9,\nreturn [**0**, **1**].\n</code></pre><h3 id=\"题解-哈希表\"><a href=\"#题解-哈希表\" class=\"headerlink\" title=\"题解 - 哈希表\"></a>题解 - 哈希表</h3><p>找两数之和是否为<code>target</code>, 如果是找数组中一个值为<code>target</code>该多好啊！遍历一次就知道了, 难道要将数组中所有元素的两两组合都求出来与<code>target</code>比较吗？时间复杂度显然为 $O(n^2)$, 显然不符题目要求。找一个数时直接遍历即可，那么可不可以将两个数之和转换为找一个数呢？我们先来看看两数之和为<code>target</code>所对应的判断条件—— $x_i + x_j = target$, 可进一步转化为 $x_i = target - x_j$, 其中 $i$ 和 $j$ 为数组中的下标。一段神奇的数学推理就<strong>将找两数之和转化为了找一个数是否在数组中了</strong>！<br>基本思路有了，现在就来看看怎么实现，显然我们需要额外的空间(也就是哈希表)来保存已经处理过的 $x_j$(<strong>注意这里并不能先初始化哈希表，否则无法排除两个相同的元素相加为 target 的情况</strong>), 如果不满足等式条件，那么我们就往后遍历，并把之前的元素加入到哈希表中，如果<code>target</code>减去当前索引后的值在哈希表中找到了，那么就将哈希表中相应的索引返回，大功告成！</p>\n<p><strong>万能的哈希！！！！</strong></p>\n<h3 id=\"C\"><a href=\"#C\" class=\"headerlink\" title=\"C++\"></a>C++</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">class</span> Solution &#123;</div><div class=\"line\"><span class=\"keyword\">public</span>:</div><div class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; twoSum(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums, <span class=\"keyword\">int</span> target) &#123;</div><div class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; result;</div><div class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> length = nums.size();</div><div class=\"line\">        <span class=\"keyword\">if</span> (!length) &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> result;</div><div class=\"line\">        &#125;</div><div class=\"line\">    <span class=\"comment\">// first value, second index</span></div><div class=\"line\">    <span class=\"built_in\">unordered_map</span>&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt; hash(length);</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i != length; ++i) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (hash.find(target - nums[i]) != hash.end()) &#123;</div><div class=\"line\">            result.push_back(hash[target - nums[i]]);<span class=\"comment\">//index比i要小</span></div><div class=\"line\">            result.push_back(i);<span class=\"comment\">//题目要求index小的在前面</span></div><div class=\"line\">            <span class=\"keyword\">return</span> result;</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            hash[nums[i]] = i;<span class=\"comment\">//放入哈希表中 i=0先放入哈希表</span></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> result;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<h3 id=\"复杂度分析-1\"><a href=\"#复杂度分析-1\" class=\"headerlink\" title=\"复杂度分析\"></a>复杂度分析</h3><p>哈希表⽤了和数组等⻓的空间，空间复杂度为$O(n)$, 遍历⼀次数组，时间复杂度为$O(n)$.</p>\n<p>参考：<a href=\"http://www.jiuzhang.com/solutions/2-sum/\" target=\"_blank\" rel=\"external\">http://www.jiuzhang.com/solutions/2-sum/</a></p>\n<h2 id=\"3-Sum\"><a href=\"#3-Sum\" class=\"headerlink\" title=\"3 Sum\"></a>3 Sum</h2><h2 id=\"Question-1\"><a href=\"#Question-1\" class=\"headerlink\" title=\"Question\"></a>Question</h2><ul>\n<li>leetcode: <a href=\"https://leetcode.com/problems/3sum/\" target=\"_blank\" rel=\"external\">3Sum | LeetCode OJ</a></li>\n<li>lintcode: <a href=\"http://www.lintcode.com/en/problem/3sum/\" target=\"_blank\" rel=\"external\">(57) 3 Sum</a></li>\n</ul>\n<h3 id=\"Problem-Statement-2\"><a href=\"#Problem-Statement-2\" class=\"headerlink\" title=\"Problem Statement\"></a>Problem Statement</h3><p>Given an array <em>S</em> of <em>n</em> integers, are there elements <em>a</em>, <em>b</em>, <em>c</em> in <em>S</em><br>such that <em>a</em> + <em>b</em> + <em>c</em> = 0? Find all unique triplets in the array which<br>gives the sum of zero.</p>\n<h4 id=\"Note\"><a href=\"#Note\" class=\"headerlink\" title=\"Note:\"></a>Note:</h4><p>The solution set must not contain duplicate triplets.</p>\n<pre><code>For example, given array S = [-1, 0, 1, 2, -1, -4],\n\nA solution set is:\n[\n  [-1, 0, 1],\n  [-1, -1, 2]\n]\n</code></pre><h3 id=\"题解1-排序-哈希表-2-Sum\"><a href=\"#题解1-排序-哈希表-2-Sum\" class=\"headerlink\" title=\"题解1 - 排序 + 哈希表 + 2 Sum\"></a>题解1 - 排序 + 哈希表 + 2 Sum</h3><p>相比之前的 2 Sum, 3 Sum 又多加了一个数，按照之前 2 Sum 的分解为『1 Sum + 1 Sum』的思路，我们同样可以将 3 Sum 分解为『1 Sum + 2 Sum』的问题，具体就是首先对原数组排序，排序后选出第一个元素，随后在剩下的元素中使用 2 Sum 的解法。</p>\n<h3 id=\"C-1\"><a href=\"#C-1\" class=\"headerlink\" title=\"C++\"></a>C++</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">class</span> Solution &#123;</div><div class=\"line\"><span class=\"keyword\">public</span>:</div><div class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; threeSum(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums) &#123;</div><div class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &gt; result;</div><div class=\"line\">        <span class=\"keyword\">if</span> (nums.size() &lt; <span class=\"number\">3</span>) <span class=\"keyword\">return</span> result;</div><div class=\"line\">        <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</div><div class=\"line\">        sort(nums.begin(), nums.end());</div><div class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> length = nums.size();</div><div class=\"line\">        <span class=\"comment\">//for(i = 0; i &lt; nums.size() - 2; ++i)&#123; //最后2个没有可能性</span></div><div class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.size() - <span class=\"number\">2</span>; ++i)&#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (i &gt; <span class=\"number\">0</span> &amp;&amp; nums[i] == nums[i - <span class=\"number\">1</span>])</div><div class=\"line\">                <span class=\"keyword\">continue</span>; <span class=\"comment\">//重复数字跳出循环</span></div><div class=\"line\">            <span class=\"keyword\">int</span> target = <span class=\"number\">0</span> - nums[i];</div><div class=\"line\">            <span class=\"built_in\">unordered_map</span>&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt; hash(length);<span class=\"comment\">// first value, second index</span></div><div class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = i + <span class=\"number\">1</span>; j &lt; nums.size(); ++j)&#123;</div><div class=\"line\">                <span class=\"keyword\">if</span> (hash.find(target - nums[j]) != hash.end()) &#123;</div><div class=\"line\">                    result.push_back(&#123;nums[i], target - nums[j], nums[j]&#125;);</div><div class=\"line\">                    <span class=\"comment\">//result.push_front(nums[j]);//题目要求index小的在前面</span></div><div class=\"line\">                    <span class=\"comment\">//result.push_front(target - nums[j]);//index比j的index小</span></div><div class=\"line\">                    <span class=\"comment\">//return result;</span></div><div class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                    hash[nums[j]] = j;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">  </div><div class=\"line\">        &#125;</div><div class=\"line\">        result.erase(unique(result.begin(), result.end()), result.end());</div><div class=\"line\">        <span class=\"keyword\">return</span> result;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"comment\">//error:[0,0,0,0] Output:[[0,0,0],[0,0,0]] 解决：加入erase删除重复</span></div></pre></td></tr></table></figure>\n<p>或：先排序，然后左右夹逼，复杂度 $O(n^2)$。<br>这个方法可以推广到 k-sum，先排序，然后敬 k − 2 次悟环，在偎内层悟环左右夹逼，肘间复杂 度是 $O(max{n log n, n^{k−1}})$。</p>\n<h3 id=\"C-2\"><a href=\"#C-2\" class=\"headerlink\" title=\"C++\"></a>C++</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"></div></pre></td></tr></table></figure>\n","excerpt":"","more":"<p>#线性表</p>\n<h2 id=\"Longest-Consecutive-Sequence\"><a href=\"#Longest-Consecutive-Sequence\" class=\"headerlink\" title=\"Longest Consecutive Sequence\"></a>Longest Consecutive Sequence</h2><ul>\n<li>leetcode: <a href=\"https://leetcode.com/problems/longest-consecutive-sequence/\">Longest Consecutive Sequence | LeetCode OJ</a></li>\n<li>lintcode: <a href=\"http://www.lintcode.com/en/problem/longest-consecutive-sequence/\">(124) Longest Consecutive Sequence</a></li>\n</ul>\n<h3 id=\"Problem-Statement\"><a href=\"#Problem-Statement\" class=\"headerlink\" title=\"Problem Statement\"></a>Problem Statement</h3><p>Given an unsorted array of integers, find the length of the longest<br>consecutive elements sequence.</p>\n<h4 id=\"Example\"><a href=\"#Example\" class=\"headerlink\" title=\"Example\"></a>Example</h4><p>Given <code>[100, 4, 200, 1, 3, 2]</code>,<br>The longest consecutive elements sequence is <code>[1, 2, 3, 4]</code>. Return its<br>length: <code>4</code>.</p>\n<h4 id=\"Clarification\"><a href=\"#Clarification\" class=\"headerlink\" title=\"Clarification\"></a>Clarification</h4><p>Your algorithm should run in O(<em>n</em>) complexity.</p>\n<h3 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h3><p>首先看题要求，时间复杂度为 $O(n)$, 如果排序，基于比较的实现为 $O(n \\log n)$, 基数排序需要数据有特征。故排序无法达到复杂度要求。接下来可以联想空间换时间的做法，其中以哈希表为代表。这个题要求返回最长连续序列，不要求有序，非常符合哈希表的用法。<strong>由于给定一个数其连续的数要么比它小1，要么大1，那么我们只需往左往右搜索知道在数组中找不到数为止。</strong>结合哈希表查找为 $O(1)$ 的特性即可满足要求。用一个哈希表 <figure class=\"highlight plain\"><figcaption><span>bool> used``` 记录每个元素是否使用，对每个元素，以该元素为中心，往左右扩张，直到不连续为止，记录下贵长的长度。</span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">详细说明：你看到[100, 4, 200, 1, 3, 2]这个数组，首先你会看99或者101在不在这个数组里，发现数组没这两个数，那么100组成的连续序列长度仅为1。接着会看5或者3在不在数组里，会发现3存在，5不存在；紧接着会看2在不在....直到发现0不在。从而得到4组成的最长序列为4。</div><div class=\"line\">总结一下会发现，我们在判断某个数的连续序列时，会分别往减小和增大的方向找下一个连续数在不在数组中。然后把两个方向的长度加起来即为包含该数的一个连续序列。需要注意的是，当前数的长度计数只需要出现在一个方向的查找中计算即可，否则就重复了。要找一个数是不是在数组中，不可能用遍历的方法实现，这样时间复杂度就超过$O(n)$了。而要降低时间复杂度，一个经典的方案就是空间换时间。用增加空间复杂度的方法来换取时间复杂度的降低。所以我们可以先对数组进行一次预处理，生成一份包含数组元素的哈希表。这样在求解某个数字在不在数组时就可以得到O(1)的时间复杂度。</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">### C++</div><div class=\"line\">```C++</div><div class=\"line\">class Solution &#123;</div><div class=\"line\">public:</div><div class=\"line\">    int longestConsecutive(vector&lt;int&gt;&amp; nums) &#123;</div><div class=\"line\">        unordered_map&lt;int, bool&gt; used;</div><div class=\"line\">        for (auto i : nums) used[i] = false; //遍历容器bector里的每一个元素,设为false</div><div class=\"line\">        //for (auto i=1;i&lt;5;i++) cout&lt;&lt;used[i];</div><div class=\"line\">        int longest = 0;</div><div class=\"line\">        for (auto i : nums) &#123;</div><div class=\"line\">            if (used[i]) continue; //防止array中有重复integar，continue跳出本次循环</div><div class=\"line\">            int length = 1;</div><div class=\"line\">            used[i] = true;</div><div class=\"line\">            for (int j = i + 1; used.find(j) != used.end(); ++j) &#123;</div><div class=\"line\">            //用find函数来定位数据出现位置，它返回的一个迭代器</div><div class=\"line\">            //如果map中没有要查找的数据，它返回的迭代器等于end函数返回的迭代器</div><div class=\"line\">                used[j] = true;</div><div class=\"line\">                ++length;</div><div class=\"line\">                &#125;</div><div class=\"line\">            for (int j = i - 1; used.find(j) != used.end(); --j) &#123;</div><div class=\"line\">                used[j] = true;</div><div class=\"line\">                ++length;</div><div class=\"line\">            &#125;</div><div class=\"line\">            longest = max(longest, length);</div><div class=\"line\">        &#125;</div><div class=\"line\">        return longest;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<h3 id=\"复杂度分析\"><a href=\"#复杂度分析\" class=\"headerlink\" title=\"复杂度分析\"></a>复杂度分析</h3><p>时间复杂度和空间复杂度均为 $O(n)$.</p>\n<p>参考：map用法：<a href=\"http://blog.sina.com.cn/s/blog_59b6af690100xy0z.html\">http://blog.sina.com.cn/s/blog_59b6af690100xy0z.html</a></p>\n<h2 id=\"Two-Sum\"><a href=\"#Two-Sum\" class=\"headerlink\" title=\"Two Sum\"></a>Two Sum</h2><p>Tags: Array, Hash Table, Easy</p>\n<h2 id=\"Question\"><a href=\"#Question\" class=\"headerlink\" title=\"Question\"></a>Question</h2><ul>\n<li>leetcode: <a href=\"https://leetcode.com/problems/two-sum/\">Two Sum</a></li>\n<li>lintcode: <a href=\"http://www.lintcode.com/en/problem/two-sum/\">Two Sum</a></li>\n</ul>\n<h3 id=\"Problem-Statement-1\"><a href=\"#Problem-Statement-1\" class=\"headerlink\" title=\"Problem Statement\"></a>Problem Statement</h3><p>Given an array of integers, return <strong>indices</strong> of the two numbers such that<br>they add up to a specific target.</p>\n<p>You may assume that each input would have <strong><em>exactly</em></strong> one solution, and you<br>may not use the <em>same</em> element twice.</p>\n<p><strong>Example:</strong>  </p>\n<pre><code>Given nums = [2, 7, 11, 15], target = 9,\n\nBecause nums[**0**] + nums[**1**] = 2 + 7 = 9,\nreturn [**0**, **1**].\n</code></pre><h3 id=\"题解-哈希表\"><a href=\"#题解-哈希表\" class=\"headerlink\" title=\"题解 - 哈希表\"></a>题解 - 哈希表</h3><p>找两数之和是否为<code>target</code>, 如果是找数组中一个值为<code>target</code>该多好啊！遍历一次就知道了, 难道要将数组中所有元素的两两组合都求出来与<code>target</code>比较吗？时间复杂度显然为 $O(n^2)$, 显然不符题目要求。找一个数时直接遍历即可，那么可不可以将两个数之和转换为找一个数呢？我们先来看看两数之和为<code>target</code>所对应的判断条件—— $x_i + x_j = target$, 可进一步转化为 $x_i = target - x_j$, 其中 $i$ 和 $j$ 为数组中的下标。一段神奇的数学推理就<strong>将找两数之和转化为了找一个数是否在数组中了</strong>！<br>基本思路有了，现在就来看看怎么实现，显然我们需要额外的空间(也就是哈希表)来保存已经处理过的 $x_j$(<strong>注意这里并不能先初始化哈希表，否则无法排除两个相同的元素相加为 target 的情况</strong>), 如果不满足等式条件，那么我们就往后遍历，并把之前的元素加入到哈希表中，如果<code>target</code>减去当前索引后的值在哈希表中找到了，那么就将哈希表中相应的索引返回，大功告成！</p>\n<p><strong>万能的哈希！！！！</strong></p>\n<h3 id=\"C\"><a href=\"#C\" class=\"headerlink\" title=\"C++\"></a>C++</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">class</span> Solution &#123;</div><div class=\"line\"><span class=\"keyword\">public</span>:</div><div class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; twoSum(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums, <span class=\"keyword\">int</span> target) &#123;</div><div class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; result;</div><div class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> length = nums.size();</div><div class=\"line\">        <span class=\"keyword\">if</span> (!length) &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> result;</div><div class=\"line\">        &#125;</div><div class=\"line\">    <span class=\"comment\">// first value, second index</span></div><div class=\"line\">    <span class=\"built_in\">unordered_map</span>&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt; hash(length);</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i != length; ++i) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (hash.find(target - nums[i]) != hash.end()) &#123;</div><div class=\"line\">            result.push_back(hash[target - nums[i]]);<span class=\"comment\">//index比i要小</span></div><div class=\"line\">            result.push_back(i);<span class=\"comment\">//题目要求index小的在前面</span></div><div class=\"line\">            <span class=\"keyword\">return</span> result;</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            hash[nums[i]] = i;<span class=\"comment\">//放入哈希表中 i=0先放入哈希表</span></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> result;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<h3 id=\"复杂度分析-1\"><a href=\"#复杂度分析-1\" class=\"headerlink\" title=\"复杂度分析\"></a>复杂度分析</h3><p>哈希表⽤了和数组等⻓的空间，空间复杂度为$O(n)$, 遍历⼀次数组，时间复杂度为$O(n)$.</p>\n<p>参考：<a href=\"http://www.jiuzhang.com/solutions/2-sum/\">http://www.jiuzhang.com/solutions/2-sum/</a></p>\n<h2 id=\"3-Sum\"><a href=\"#3-Sum\" class=\"headerlink\" title=\"3 Sum\"></a>3 Sum</h2><h2 id=\"Question-1\"><a href=\"#Question-1\" class=\"headerlink\" title=\"Question\"></a>Question</h2><ul>\n<li>leetcode: <a href=\"https://leetcode.com/problems/3sum/\">3Sum | LeetCode OJ</a></li>\n<li>lintcode: <a href=\"http://www.lintcode.com/en/problem/3sum/\">(57) 3 Sum</a></li>\n</ul>\n<h3 id=\"Problem-Statement-2\"><a href=\"#Problem-Statement-2\" class=\"headerlink\" title=\"Problem Statement\"></a>Problem Statement</h3><p>Given an array <em>S</em> of <em>n</em> integers, are there elements <em>a</em>, <em>b</em>, <em>c</em> in <em>S</em><br>such that <em>a</em> + <em>b</em> + <em>c</em> = 0? Find all unique triplets in the array which<br>gives the sum of zero.</p>\n<h4 id=\"Note\"><a href=\"#Note\" class=\"headerlink\" title=\"Note:\"></a>Note:</h4><p>The solution set must not contain duplicate triplets.</p>\n<pre><code>For example, given array S = [-1, 0, 1, 2, -1, -4],\n\nA solution set is:\n[\n  [-1, 0, 1],\n  [-1, -1, 2]\n]\n</code></pre><h3 id=\"题解1-排序-哈希表-2-Sum\"><a href=\"#题解1-排序-哈希表-2-Sum\" class=\"headerlink\" title=\"题解1 - 排序 + 哈希表 + 2 Sum\"></a>题解1 - 排序 + 哈希表 + 2 Sum</h3><p>相比之前的 2 Sum, 3 Sum 又多加了一个数，按照之前 2 Sum 的分解为『1 Sum + 1 Sum』的思路，我们同样可以将 3 Sum 分解为『1 Sum + 2 Sum』的问题，具体就是首先对原数组排序，排序后选出第一个元素，随后在剩下的元素中使用 2 Sum 的解法。</p>\n<h3 id=\"C-1\"><a href=\"#C-1\" class=\"headerlink\" title=\"C++\"></a>C++</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">class</span> Solution &#123;</div><div class=\"line\"><span class=\"keyword\">public</span>:</div><div class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; threeSum(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums) &#123;</div><div class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &gt; result;</div><div class=\"line\">        <span class=\"keyword\">if</span> (nums.size() &lt; <span class=\"number\">3</span>) <span class=\"keyword\">return</span> result;</div><div class=\"line\">        <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</div><div class=\"line\">        sort(nums.begin(), nums.end());</div><div class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> length = nums.size();</div><div class=\"line\">        <span class=\"comment\">//for(i = 0; i &lt; nums.size() - 2; ++i)&#123; //最后2个没有可能性</span></div><div class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.size() - <span class=\"number\">2</span>; ++i)&#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (i &gt; <span class=\"number\">0</span> &amp;&amp; nums[i] == nums[i - <span class=\"number\">1</span>])</div><div class=\"line\">                <span class=\"keyword\">continue</span>; <span class=\"comment\">//重复数字跳出循环</span></div><div class=\"line\">            <span class=\"keyword\">int</span> target = <span class=\"number\">0</span> - nums[i];</div><div class=\"line\">            <span class=\"built_in\">unordered_map</span>&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt; hash(length);<span class=\"comment\">// first value, second index</span></div><div class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = i + <span class=\"number\">1</span>; j &lt; nums.size(); ++j)&#123;</div><div class=\"line\">                <span class=\"keyword\">if</span> (hash.find(target - nums[j]) != hash.end()) &#123;</div><div class=\"line\">                    result.push_back(&#123;nums[i], target - nums[j], nums[j]&#125;);</div><div class=\"line\">                    <span class=\"comment\">//result.push_front(nums[j]);//题目要求index小的在前面</span></div><div class=\"line\">                    <span class=\"comment\">//result.push_front(target - nums[j]);//index比j的index小</span></div><div class=\"line\">                    <span class=\"comment\">//return result;</span></div><div class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                    hash[nums[j]] = j;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">  </div><div class=\"line\">        &#125;</div><div class=\"line\">        result.erase(unique(result.begin(), result.end()), result.end());</div><div class=\"line\">        <span class=\"keyword\">return</span> result;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"comment\">//error:[0,0,0,0] Output:[[0,0,0],[0,0,0]] 解决：加入erase删除重复</span></div></pre></td></tr></table></figure>\n<p>或：先排序，然后左右夹逼，复杂度 $O(n^2)$。<br>这个方法可以推广到 k-sum，先排序，然后敬 k − 2 次悟环，在偎内层悟环左右夹逼，肘间复杂 度是 $O(max{n log n, n^{k−1}})$。</p>\n<h3 id=\"C-2\"><a href=\"#C-2\" class=\"headerlink\" title=\"C++\"></a>C++</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"></div></pre></td></tr></table></figure>\n"},{"title":"LeetCode/LintCode刷题之排序","date":"2017-03-17T08:50:03.000Z","comments":1,"mathjax":true,"_content":"# 排序\n## Merge Sorted Array\n\n## Question\n\n- leetcode: [Merge Sorted Array | LeetCode OJ](https://leetcode.com/problems/merge-sorted-array/)\n- lintcode: [(6) Merge Sorted Array](http://www.lintcode.com/en/problem/merge-sorted-array/)\n\n```\nGiven two sorted integer arrays A and B, merge B into A as one sorted array.\n\nExample\nA = [1, 2, 3, empty, empty], B = [4, 5]\n\nAfter merge, A will be filled as [1, 2, 3, 4, 5]\n\nNote\nYou may assume that A has enough space (size that is greater or equal to m + n)\nto hold additional elements from B.\nThe number of elements initialized in A and B are m and n respectively.\n```\n\n### 题解\n\n因为本题有 in-place 的限制，故必须从数组末尾的两个元素开始比较；否则就会产生挪动，一旦挪动就会是 $O(n^2)$ 的。\n自尾部向首部逐个比较两个数组内的元素，取较大的置于数组 A 中。由于 A 的容量较 B 大，故最后 `m == 0` 或者 `n == 0` 时仅需处理 B 中的元素，因为 A 中的元素已经在 A 中，无需处理。\n\n### C++\n\n```c++\nclass Solution {\npublic:\n    void merge(vector<int>& A, int m, vector<int>& B, int n) {\n        int index = m + n - 1;\n        while (m > 0 && n > 0) {\n            if (A[m - 1] > B[n - 1]) {\n                A[index] = A[m - 1];\n                --m;\n            } else {\n            A[index] = B[n - 1];\n            --n;\n            }\n        --index;\n        }\n        // 如果B非空，因为A中的元素已经在A中，m==0时，A中元素位置已调整好，B中元素不定\n        while (n > 0) {\n            A[index] = B[n - 1];\n            --n;\n            --index;\n        }\n    }\n};\n```\n### 复杂度分析\n\n最坏情况下需要遍历两个数组中所有元素，时间复杂度为 $O(m+n)$. 空间复杂度 $O(1)$.\n## Merge Two Sorted Lists\n\n## Question\n\n- leetcode: [Merge Two Sorted Lists | LeetCode OJ](https://leetcode.com/problems/merge-two-sorted-lists/)\n- lintcode: [(165) Merge Two Sorted Lists](http://www.lintcode.com/en/problem/merge-two-sorted-lists/)\n\n### Problem Statement\n\nMerge two sorted (ascending) linked lists and return it as a new sorted list.\nThe new sorted list should be made by splicing together the nodes of the two\nlists and sorted in ascending order.\n\n#### Example\n\nGiven `1->3->8->11->15->null`, `2->null` , return `1->2->3->8->11->15->null`.\n\n### 题解\n\n此题为两个链表的合并，合并后的表头节点不一定，故应联想到使用`dummy`节点。链表节点的插入主要涉及节点`next`指针值的改变，两个链表的合并操作则涉及到两个节点的`next`值变化，若每次合并一个节点都要改变两个节点`next`的值且要对`NULL`指针做异常处理，势必会异常麻烦。嗯，第一次做这个题时我就是这么想的... 下面看看相对较好的思路。\n\n首先`dummy`节点还是必须要用到，除了`dummy`节点外还引入一个`curr`节点充当下一次合并时的头节点。在`l1`或者`l2`的某一个节点为空指针`NULL`时，退出`while`循环，并将非空链表的头部链接到`curr->next`中。\n\n### C++\n","source":"_posts/LeetCodeLintCode刷题之排序.md","raw":"---\ntitle: LeetCode/LintCode刷题之排序\ndate: 2017-3-17 16:50:03\ncomments: true\nmathjax: true\ncategories:\n\t- 刷题\n\t- 面试\ntags: \n\t- C++\n\t- Python\n---\n# 排序\n## Merge Sorted Array\n\n## Question\n\n- leetcode: [Merge Sorted Array | LeetCode OJ](https://leetcode.com/problems/merge-sorted-array/)\n- lintcode: [(6) Merge Sorted Array](http://www.lintcode.com/en/problem/merge-sorted-array/)\n\n```\nGiven two sorted integer arrays A and B, merge B into A as one sorted array.\n\nExample\nA = [1, 2, 3, empty, empty], B = [4, 5]\n\nAfter merge, A will be filled as [1, 2, 3, 4, 5]\n\nNote\nYou may assume that A has enough space (size that is greater or equal to m + n)\nto hold additional elements from B.\nThe number of elements initialized in A and B are m and n respectively.\n```\n\n### 题解\n\n因为本题有 in-place 的限制，故必须从数组末尾的两个元素开始比较；否则就会产生挪动，一旦挪动就会是 $O(n^2)$ 的。\n自尾部向首部逐个比较两个数组内的元素，取较大的置于数组 A 中。由于 A 的容量较 B 大，故最后 `m == 0` 或者 `n == 0` 时仅需处理 B 中的元素，因为 A 中的元素已经在 A 中，无需处理。\n\n### C++\n\n```c++\nclass Solution {\npublic:\n    void merge(vector<int>& A, int m, vector<int>& B, int n) {\n        int index = m + n - 1;\n        while (m > 0 && n > 0) {\n            if (A[m - 1] > B[n - 1]) {\n                A[index] = A[m - 1];\n                --m;\n            } else {\n            A[index] = B[n - 1];\n            --n;\n            }\n        --index;\n        }\n        // 如果B非空，因为A中的元素已经在A中，m==0时，A中元素位置已调整好，B中元素不定\n        while (n > 0) {\n            A[index] = B[n - 1];\n            --n;\n            --index;\n        }\n    }\n};\n```\n### 复杂度分析\n\n最坏情况下需要遍历两个数组中所有元素，时间复杂度为 $O(m+n)$. 空间复杂度 $O(1)$.\n## Merge Two Sorted Lists\n\n## Question\n\n- leetcode: [Merge Two Sorted Lists | LeetCode OJ](https://leetcode.com/problems/merge-two-sorted-lists/)\n- lintcode: [(165) Merge Two Sorted Lists](http://www.lintcode.com/en/problem/merge-two-sorted-lists/)\n\n### Problem Statement\n\nMerge two sorted (ascending) linked lists and return it as a new sorted list.\nThe new sorted list should be made by splicing together the nodes of the two\nlists and sorted in ascending order.\n\n#### Example\n\nGiven `1->3->8->11->15->null`, `2->null` , return `1->2->3->8->11->15->null`.\n\n### 题解\n\n此题为两个链表的合并，合并后的表头节点不一定，故应联想到使用`dummy`节点。链表节点的插入主要涉及节点`next`指针值的改变，两个链表的合并操作则涉及到两个节点的`next`值变化，若每次合并一个节点都要改变两个节点`next`的值且要对`NULL`指针做异常处理，势必会异常麻烦。嗯，第一次做这个题时我就是这么想的... 下面看看相对较好的思路。\n\n首先`dummy`节点还是必须要用到，除了`dummy`节点外还引入一个`curr`节点充当下一次合并时的头节点。在`l1`或者`l2`的某一个节点为空指针`NULL`时，退出`while`循环，并将非空链表的头部链接到`curr->next`中。\n\n### C++\n","slug":"LeetCodeLintCode刷题之排序","published":1,"updated":"2017-04-12T07:40:50.617Z","layout":"post","photos":[],"link":"","_id":"cj23iflz30007golakkux4flq","content":"<h1 id=\"排序\"><a href=\"#排序\" class=\"headerlink\" title=\"排序\"></a>排序</h1><h2 id=\"Merge-Sorted-Array\"><a href=\"#Merge-Sorted-Array\" class=\"headerlink\" title=\"Merge Sorted Array\"></a>Merge Sorted Array</h2><h2 id=\"Question\"><a href=\"#Question\" class=\"headerlink\" title=\"Question\"></a>Question</h2><ul>\n<li>leetcode: <a href=\"https://leetcode.com/problems/merge-sorted-array/\" target=\"_blank\" rel=\"external\">Merge Sorted Array | LeetCode OJ</a></li>\n<li>lintcode: <a href=\"http://www.lintcode.com/en/problem/merge-sorted-array/\" target=\"_blank\" rel=\"external\">(6) Merge Sorted Array</a></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">Given two sorted integer arrays A and B, merge B into A as one sorted array.</div><div class=\"line\"></div><div class=\"line\">Example</div><div class=\"line\">A = [1, 2, 3, empty, empty], B = [4, 5]</div><div class=\"line\"></div><div class=\"line\">After merge, A will be filled as [1, 2, 3, 4, 5]</div><div class=\"line\"></div><div class=\"line\">Note</div><div class=\"line\">You may assume that A has enough space (size that is greater or equal to m + n)</div><div class=\"line\">to hold additional elements from B.</div><div class=\"line\">The number of elements initialized in A and B are m and n respectively.</div></pre></td></tr></table></figure>\n<h3 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h3><p>因为本题有 in-place 的限制，故必须从数组末尾的两个元素开始比较；否则就会产生挪动，一旦挪动就会是 $O(n^2)$ 的。<br>自尾部向首部逐个比较两个数组内的元素，取较大的置于数组 A 中。由于 A 的容量较 B 大，故最后 <code>m == 0</code> 或者 <code>n == 0</code> 时仅需处理 B 中的元素，因为 A 中的元素已经在 A 中，无需处理。</p>\n<h3 id=\"C\"><a href=\"#C\" class=\"headerlink\" title=\"C++\"></a>C++</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">class</span> Solution &#123;</div><div class=\"line\"><span class=\"keyword\">public</span>:</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">merge</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; A, <span class=\"keyword\">int</span> m, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; B, <span class=\"keyword\">int</span> n)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> index = m + n - <span class=\"number\">1</span>;</div><div class=\"line\">        <span class=\"keyword\">while</span> (m &gt; <span class=\"number\">0</span> &amp;&amp; n &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (A[m - <span class=\"number\">1</span>] &gt; B[n - <span class=\"number\">1</span>]) &#123;</div><div class=\"line\">                A[index] = A[m - <span class=\"number\">1</span>];</div><div class=\"line\">                --m;</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            A[index] = B[n - <span class=\"number\">1</span>];</div><div class=\"line\">            --n;</div><div class=\"line\">            &#125;</div><div class=\"line\">        --index;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"comment\">// 如果B非空，因为A中的元素已经在A中，m==0时，A中元素位置已调整好，B中元素不定</span></div><div class=\"line\">        <span class=\"keyword\">while</span> (n &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">            A[index] = B[n - <span class=\"number\">1</span>];</div><div class=\"line\">            --n;</div><div class=\"line\">            --index;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<h3 id=\"复杂度分析\"><a href=\"#复杂度分析\" class=\"headerlink\" title=\"复杂度分析\"></a>复杂度分析</h3><p>最坏情况下需要遍历两个数组中所有元素，时间复杂度为 $O(m+n)$. 空间复杂度 $O(1)$.</p>\n<h2 id=\"Merge-Two-Sorted-Lists\"><a href=\"#Merge-Two-Sorted-Lists\" class=\"headerlink\" title=\"Merge Two Sorted Lists\"></a>Merge Two Sorted Lists</h2><h2 id=\"Question-1\"><a href=\"#Question-1\" class=\"headerlink\" title=\"Question\"></a>Question</h2><ul>\n<li>leetcode: <a href=\"https://leetcode.com/problems/merge-two-sorted-lists/\" target=\"_blank\" rel=\"external\">Merge Two Sorted Lists | LeetCode OJ</a></li>\n<li>lintcode: <a href=\"http://www.lintcode.com/en/problem/merge-two-sorted-lists/\" target=\"_blank\" rel=\"external\">(165) Merge Two Sorted Lists</a></li>\n</ul>\n<h3 id=\"Problem-Statement\"><a href=\"#Problem-Statement\" class=\"headerlink\" title=\"Problem Statement\"></a>Problem Statement</h3><p>Merge two sorted (ascending) linked lists and return it as a new sorted list.<br>The new sorted list should be made by splicing together the nodes of the two<br>lists and sorted in ascending order.</p>\n<h4 id=\"Example\"><a href=\"#Example\" class=\"headerlink\" title=\"Example\"></a>Example</h4><p>Given <code>1-&gt;3-&gt;8-&gt;11-&gt;15-&gt;null</code>, <code>2-&gt;null</code> , return <code>1-&gt;2-&gt;3-&gt;8-&gt;11-&gt;15-&gt;null</code>.</p>\n<h3 id=\"题解-1\"><a href=\"#题解-1\" class=\"headerlink\" title=\"题解\"></a>题解</h3><p>此题为两个链表的合并，合并后的表头节点不一定，故应联想到使用<code>dummy</code>节点。链表节点的插入主要涉及节点<code>next</code>指针值的改变，两个链表的合并操作则涉及到两个节点的<code>next</code>值变化，若每次合并一个节点都要改变两个节点<code>next</code>的值且要对<code>NULL</code>指针做异常处理，势必会异常麻烦。嗯，第一次做这个题时我就是这么想的… 下面看看相对较好的思路。</p>\n<p>首先<code>dummy</code>节点还是必须要用到，除了<code>dummy</code>节点外还引入一个<code>curr</code>节点充当下一次合并时的头节点。在<code>l1</code>或者<code>l2</code>的某一个节点为空指针<code>NULL</code>时，退出<code>while</code>循环，并将非空链表的头部链接到<code>curr-&gt;next</code>中。</p>\n<h3 id=\"C-1\"><a href=\"#C-1\" class=\"headerlink\" title=\"C++\"></a>C++</h3>","excerpt":"","more":"<h1 id=\"排序\"><a href=\"#排序\" class=\"headerlink\" title=\"排序\"></a>排序</h1><h2 id=\"Merge-Sorted-Array\"><a href=\"#Merge-Sorted-Array\" class=\"headerlink\" title=\"Merge Sorted Array\"></a>Merge Sorted Array</h2><h2 id=\"Question\"><a href=\"#Question\" class=\"headerlink\" title=\"Question\"></a>Question</h2><ul>\n<li>leetcode: <a href=\"https://leetcode.com/problems/merge-sorted-array/\">Merge Sorted Array | LeetCode OJ</a></li>\n<li>lintcode: <a href=\"http://www.lintcode.com/en/problem/merge-sorted-array/\">(6) Merge Sorted Array</a></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">Given two sorted integer arrays A and B, merge B into A as one sorted array.</div><div class=\"line\"></div><div class=\"line\">Example</div><div class=\"line\">A = [1, 2, 3, empty, empty], B = [4, 5]</div><div class=\"line\"></div><div class=\"line\">After merge, A will be filled as [1, 2, 3, 4, 5]</div><div class=\"line\"></div><div class=\"line\">Note</div><div class=\"line\">You may assume that A has enough space (size that is greater or equal to m + n)</div><div class=\"line\">to hold additional elements from B.</div><div class=\"line\">The number of elements initialized in A and B are m and n respectively.</div></pre></td></tr></table></figure>\n<h3 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h3><p>因为本题有 in-place 的限制，故必须从数组末尾的两个元素开始比较；否则就会产生挪动，一旦挪动就会是 $O(n^2)$ 的。<br>自尾部向首部逐个比较两个数组内的元素，取较大的置于数组 A 中。由于 A 的容量较 B 大，故最后 <code>m == 0</code> 或者 <code>n == 0</code> 时仅需处理 B 中的元素，因为 A 中的元素已经在 A 中，无需处理。</p>\n<h3 id=\"C\"><a href=\"#C\" class=\"headerlink\" title=\"C++\"></a>C++</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">class</span> Solution &#123;</div><div class=\"line\"><span class=\"keyword\">public</span>:</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">merge</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; A, <span class=\"keyword\">int</span> m, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; B, <span class=\"keyword\">int</span> n)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> index = m + n - <span class=\"number\">1</span>;</div><div class=\"line\">        <span class=\"keyword\">while</span> (m &gt; <span class=\"number\">0</span> &amp;&amp; n &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (A[m - <span class=\"number\">1</span>] &gt; B[n - <span class=\"number\">1</span>]) &#123;</div><div class=\"line\">                A[index] = A[m - <span class=\"number\">1</span>];</div><div class=\"line\">                --m;</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            A[index] = B[n - <span class=\"number\">1</span>];</div><div class=\"line\">            --n;</div><div class=\"line\">            &#125;</div><div class=\"line\">        --index;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"comment\">// 如果B非空，因为A中的元素已经在A中，m==0时，A中元素位置已调整好，B中元素不定</span></div><div class=\"line\">        <span class=\"keyword\">while</span> (n &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">            A[index] = B[n - <span class=\"number\">1</span>];</div><div class=\"line\">            --n;</div><div class=\"line\">            --index;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<h3 id=\"复杂度分析\"><a href=\"#复杂度分析\" class=\"headerlink\" title=\"复杂度分析\"></a>复杂度分析</h3><p>最坏情况下需要遍历两个数组中所有元素，时间复杂度为 $O(m+n)$. 空间复杂度 $O(1)$.</p>\n<h2 id=\"Merge-Two-Sorted-Lists\"><a href=\"#Merge-Two-Sorted-Lists\" class=\"headerlink\" title=\"Merge Two Sorted Lists\"></a>Merge Two Sorted Lists</h2><h2 id=\"Question-1\"><a href=\"#Question-1\" class=\"headerlink\" title=\"Question\"></a>Question</h2><ul>\n<li>leetcode: <a href=\"https://leetcode.com/problems/merge-two-sorted-lists/\">Merge Two Sorted Lists | LeetCode OJ</a></li>\n<li>lintcode: <a href=\"http://www.lintcode.com/en/problem/merge-two-sorted-lists/\">(165) Merge Two Sorted Lists</a></li>\n</ul>\n<h3 id=\"Problem-Statement\"><a href=\"#Problem-Statement\" class=\"headerlink\" title=\"Problem Statement\"></a>Problem Statement</h3><p>Merge two sorted (ascending) linked lists and return it as a new sorted list.<br>The new sorted list should be made by splicing together the nodes of the two<br>lists and sorted in ascending order.</p>\n<h4 id=\"Example\"><a href=\"#Example\" class=\"headerlink\" title=\"Example\"></a>Example</h4><p>Given <code>1-&gt;3-&gt;8-&gt;11-&gt;15-&gt;null</code>, <code>2-&gt;null</code> , return <code>1-&gt;2-&gt;3-&gt;8-&gt;11-&gt;15-&gt;null</code>.</p>\n<h3 id=\"题解-1\"><a href=\"#题解-1\" class=\"headerlink\" title=\"题解\"></a>题解</h3><p>此题为两个链表的合并，合并后的表头节点不一定，故应联想到使用<code>dummy</code>节点。链表节点的插入主要涉及节点<code>next</code>指针值的改变，两个链表的合并操作则涉及到两个节点的<code>next</code>值变化，若每次合并一个节点都要改变两个节点<code>next</code>的值且要对<code>NULL</code>指针做异常处理，势必会异常麻烦。嗯，第一次做这个题时我就是这么想的… 下面看看相对较好的思路。</p>\n<p>首先<code>dummy</code>节点还是必须要用到，除了<code>dummy</code>节点外还引入一个<code>curr</code>节点充当下一次合并时的头节点。在<code>l1</code>或者<code>l2</code>的某一个节点为空指针<code>NULL</code>时，退出<code>while</code>循环，并将非空链表的头部链接到<code>curr-&gt;next</code>中。</p>\n<h3 id=\"C-1\"><a href=\"#C-1\" class=\"headerlink\" title=\"C++\"></a>C++</h3>"},{"title":"Markdown语法","date":"2016-11-17T08:50:03.000Z","comments":1,"_content":"\n## 主要内容 ##\n> #### Markdown是_什么_？ ####\n> #### _为什么_要使用它？ ####\n> #### _怎么_使用？ ####\n> #### 都_谁_在用？####\n> #### 感觉有意思？_不怕你看见，就怕你试试_ ####\n<!--more-->\n\n## 正文 ##\n### 1. Markdown是*什么*？ ###\n**Markdown**是一种轻量级**标记语言**，它以纯文本形式(_易读、易写、易更改_)编写文档，并最终以HTML格式发布。    \n**Markdown**也可以理解为将以MARKDOWN语言编写的语言转换成HTML内容的工具，最初是一个perl脚本_Markdown.pl_。    \n\n### 2. _为什么_要使用它？ ###\n+ 它是易读（_看起开舒服_）、易写（_语法简单_）、易更改**纯文本**。处处体现着**极简主义**的影子。\n+ 兼容HTML，可以转换为HTML格式发布。\n+ 跨平台使用。\n+ 越来越多的网站支持Markdown。\n+ 更方便清晰的组织你的电子邮件。（Markdown-here, Airmail）\n+ 摆脱Word（我不是认真的）。\n \n### 3. _怎么_使用？ ###\n如果不算**扩展**，Markdown的语法绝对**简单**到让你爱不释手。\n\n废话太多，下面正文，Markdown语法主要分为如下几大部分：\n**标题**，**段落**，**区块引用**，**代码区块**，**强调**，**列表**，**分割线**，**链接**，**图片**，**反斜杠 `\\`**，**符号'`'**。\n\n#### 3.1 标题 ####\n两种形式：  \n1）使用`=`和`-`标记一级和二级标题。\n> 一级标题   \n> `=========`   \n> 二级标题    \n> `---------`\n  \n效果：\n> 一级标题   \n> =========   \n> 二级标题\n> ---------  \n\n2）使用`#`，可表示1-6级标题。\n> \\# 一级标题   \n> \\## 二级标题   \n> \\### 三级标题   \n> \\#### 四级标题   \n> \\##### 五级标题   \n> \\###### 六级标题    \n\n效果：\n> # 一级标题   \n> ## 二级标题   \n> ### 三级标题   \n> #### 四级标题   \n> ##### 五级标题   \n> ###### 六级标题 \n\n#### 3.2 段落 ####\n段落的前后要有空行，所谓的空行是指没有文字内容。若想在段内强制换行的方式是使用**两个以上**空格加上回车（引用中换行省略回车）。\n\n#### 3.3 区块引用 ####\n在段落的每行或者只在第一行使用符号`>`,还可使用多个嵌套引用，如：\n> \\> 区块引用  \n> \\>> 嵌套引用  \n\n效果：\n> 区块引用  \n>> 嵌套引用 \n\n#### 3.4 代码区块 ####\n代码区块的建立是在每行加上4个空格或者一个制表符（如同写代码一样）。如    \n普通段落：\n\nvoid main()    \n{    \n    printf(\"Hello, Markdown.\");    \n}    \n\n代码区块：\n\n    void main()\n    {\n        printf(\"Hello, Markdown.\");\n    }\n\n**注意**:需要和普通段落之间存在空行。\n\n#### 3.5 强调 ####\n在强调内容两侧分别加上`*`或者`_`，如：\n> \\*斜体\\*，\\_斜体\\_    \n> \\*\\*粗体\\*\\*，\\_\\_粗体\\_\\_\n\n效果：\n> *斜体*，_斜体_    \n> **粗体**，__粗体__\n\n#### 3.6 列表 ####\n使用`·`、`+`、或`-`标记无序列表，如：\n> \\-（+\\*） 第一项\n> \\-（+\\*） 第二项\n> \\- （+\\*）第三项\n\n**注意**：标记后面最少有一个_空格_或_制表符_。若不在引用区块中，必须和前方段落之间存在空行。\n\n效果：\n> + 第一项\n> + 第二项\n> + 第三项\n\n有序列表的标记方式是将上述的符号换成数字,并辅以`.`，如：\n> 1 . 第一项   \n> 2 . 第二项    \n> 3 . 第三项    \n\n效果：\n> 1. 第一项\n> 2. 第二项\n> 3. 第三项\n\n#### 3.7 分割线 ####\n分割线最常使用就是三个或以上`*`，还可以使用`-`和`_`。\n\n#### 3.8 链接 ####\n链接可以由两种形式生成：**行内式**和**参考式**。    \n**行内式**：\n> \\[younghz的Markdown库\\]\\(https:://github.com/younghz/Markdown \"Markdown\"\\)。\n\n效果：\n> [younghz的Markdown库](https:://github.com/younghz/Markdown \"Markdown\")。\n\n**参考式**：\n> \\[younghz的Markdown库1\\]\\[1\\]    \n> \\[younghz的Markdown库2\\]\\[2\\]    \n> \\[1\\]:https:://github.com/younghz/Markdown \"Markdown\"    \n> \\[2\\]:https:://github.com/younghz/Markdown \"Markdown\"    \n\n效果：\n> [younghz的Markdown库1][1]    \n> [younghz的Markdown库2][2]\n\n[1]: https:://github.com/younghz/Markdown \"Markdown\"\n[2]: https:://github.com/younghz/Markdown \"Markdown\"\n\n**注意**：上述的`[1]:https:://github.com/younghz/Markdown \"Markdown\"`不出现在区块中。\n\n#### 3.9 图片 ####\n添加图片的形式和链接相似，只需在链接的基础上前方加一个`！`。\n#### 3.10 反斜杠`\\` ####\n相当于**反转义**作用。使符号成为普通符号。\n#### 3.11 符号'`' ####\n起到标记作用。如：\n>\\`ctrl+a\\`\n\n效果：\n>`ctrl+a`    \n\n#### 4. 都_谁_在用？####\nMarkdown的使用者：\n+ GitHub\n+ 简书\n+ Stack Overflow\n+ Apollo\n+ Moodle\n+ Reddit\n+ 等等\n\n#### 5. 感觉有意思？趁热打铁，推荐几个_工具_。 ####\n+ **Chrome**下的stackedit插件可以离线使用，很爽。也不用担心平台受限。\n在线的dillinger.io算是评价好的了，可是不能离线使用。    \n+ **Windowns**下的MarkdownPad也用过，不过免费版的体验不是很好。    \n+ **Mac**下的Mou是国人贡献的，口碑很好。推荐。    \n+ **Linux**下的ReText不错。    \n\n**其实在对语法了如于心的话，直接用编辑器就可以了，脑子里满满的都是格式化好的文本啊。**\n我现在使用`马克飞象` + `Markdown-here`，先编辑好，然后一键格式化，挺方便。\n\n****\n**注意**：不同的Markdown解释器或工具对相应语法（扩展语法）的解释效果不尽相同，具体可参见工具的使用说明。\n虽然有人想出面搞一个所谓的标准化的Markdown，[没想到还惹怒了健在的创始人John Gruber]\n(http://blog.codinghorror.com/standard-markdown-is-now-common-markdown/)。\n****\n以上基本是所有traditonal markdown的语法。\n\n### 其它： ###\n列表的使用(非traditonal markdown)：\n\n用`|`表示表格纵向边界，表头和表内容用`-`隔开，并可用`:`进行对齐设置，两边都有`:`则表示居中，若不加`:`则默认左对齐。\n\n|代码库                              |链接                                |\n|:------------------------------------:|------------------------------------|\n|MarkDown                              |[https://github.com/younghz/Markdown](https://github.com/younghz/Markdown \"Markdown\")|\n|moos-young                            |[https://github.com/younghz/moos-young](https://github.com/younghz/moos-young \"tianchi\")|\n\n关于其它扩展语法可参见具体工具的使用说明。\n\nModified based on :[younghz's Github](http://younghz.github.io/Markdown/)\n\n\n","source":"_posts/Markdown语法.md","raw":"---\ntitle: Markdown语法\ndate: 2016-11-17 16:50:03\ncomments: true\ncategories:\n\t- 其它\ntags: \n\t- markdown\n---\n\n## 主要内容 ##\n> #### Markdown是_什么_？ ####\n> #### _为什么_要使用它？ ####\n> #### _怎么_使用？ ####\n> #### 都_谁_在用？####\n> #### 感觉有意思？_不怕你看见，就怕你试试_ ####\n<!--more-->\n\n## 正文 ##\n### 1. Markdown是*什么*？ ###\n**Markdown**是一种轻量级**标记语言**，它以纯文本形式(_易读、易写、易更改_)编写文档，并最终以HTML格式发布。    \n**Markdown**也可以理解为将以MARKDOWN语言编写的语言转换成HTML内容的工具，最初是一个perl脚本_Markdown.pl_。    \n\n### 2. _为什么_要使用它？ ###\n+ 它是易读（_看起开舒服_）、易写（_语法简单_）、易更改**纯文本**。处处体现着**极简主义**的影子。\n+ 兼容HTML，可以转换为HTML格式发布。\n+ 跨平台使用。\n+ 越来越多的网站支持Markdown。\n+ 更方便清晰的组织你的电子邮件。（Markdown-here, Airmail）\n+ 摆脱Word（我不是认真的）。\n \n### 3. _怎么_使用？ ###\n如果不算**扩展**，Markdown的语法绝对**简单**到让你爱不释手。\n\n废话太多，下面正文，Markdown语法主要分为如下几大部分：\n**标题**，**段落**，**区块引用**，**代码区块**，**强调**，**列表**，**分割线**，**链接**，**图片**，**反斜杠 `\\`**，**符号'`'**。\n\n#### 3.1 标题 ####\n两种形式：  \n1）使用`=`和`-`标记一级和二级标题。\n> 一级标题   \n> `=========`   \n> 二级标题    \n> `---------`\n  \n效果：\n> 一级标题   \n> =========   \n> 二级标题\n> ---------  \n\n2）使用`#`，可表示1-6级标题。\n> \\# 一级标题   \n> \\## 二级标题   \n> \\### 三级标题   \n> \\#### 四级标题   \n> \\##### 五级标题   \n> \\###### 六级标题    \n\n效果：\n> # 一级标题   \n> ## 二级标题   \n> ### 三级标题   \n> #### 四级标题   \n> ##### 五级标题   \n> ###### 六级标题 \n\n#### 3.2 段落 ####\n段落的前后要有空行，所谓的空行是指没有文字内容。若想在段内强制换行的方式是使用**两个以上**空格加上回车（引用中换行省略回车）。\n\n#### 3.3 区块引用 ####\n在段落的每行或者只在第一行使用符号`>`,还可使用多个嵌套引用，如：\n> \\> 区块引用  \n> \\>> 嵌套引用  \n\n效果：\n> 区块引用  \n>> 嵌套引用 \n\n#### 3.4 代码区块 ####\n代码区块的建立是在每行加上4个空格或者一个制表符（如同写代码一样）。如    \n普通段落：\n\nvoid main()    \n{    \n    printf(\"Hello, Markdown.\");    \n}    \n\n代码区块：\n\n    void main()\n    {\n        printf(\"Hello, Markdown.\");\n    }\n\n**注意**:需要和普通段落之间存在空行。\n\n#### 3.5 强调 ####\n在强调内容两侧分别加上`*`或者`_`，如：\n> \\*斜体\\*，\\_斜体\\_    \n> \\*\\*粗体\\*\\*，\\_\\_粗体\\_\\_\n\n效果：\n> *斜体*，_斜体_    \n> **粗体**，__粗体__\n\n#### 3.6 列表 ####\n使用`·`、`+`、或`-`标记无序列表，如：\n> \\-（+\\*） 第一项\n> \\-（+\\*） 第二项\n> \\- （+\\*）第三项\n\n**注意**：标记后面最少有一个_空格_或_制表符_。若不在引用区块中，必须和前方段落之间存在空行。\n\n效果：\n> + 第一项\n> + 第二项\n> + 第三项\n\n有序列表的标记方式是将上述的符号换成数字,并辅以`.`，如：\n> 1 . 第一项   \n> 2 . 第二项    \n> 3 . 第三项    \n\n效果：\n> 1. 第一项\n> 2. 第二项\n> 3. 第三项\n\n#### 3.7 分割线 ####\n分割线最常使用就是三个或以上`*`，还可以使用`-`和`_`。\n\n#### 3.8 链接 ####\n链接可以由两种形式生成：**行内式**和**参考式**。    \n**行内式**：\n> \\[younghz的Markdown库\\]\\(https:://github.com/younghz/Markdown \"Markdown\"\\)。\n\n效果：\n> [younghz的Markdown库](https:://github.com/younghz/Markdown \"Markdown\")。\n\n**参考式**：\n> \\[younghz的Markdown库1\\]\\[1\\]    \n> \\[younghz的Markdown库2\\]\\[2\\]    \n> \\[1\\]:https:://github.com/younghz/Markdown \"Markdown\"    \n> \\[2\\]:https:://github.com/younghz/Markdown \"Markdown\"    \n\n效果：\n> [younghz的Markdown库1][1]    \n> [younghz的Markdown库2][2]\n\n[1]: https:://github.com/younghz/Markdown \"Markdown\"\n[2]: https:://github.com/younghz/Markdown \"Markdown\"\n\n**注意**：上述的`[1]:https:://github.com/younghz/Markdown \"Markdown\"`不出现在区块中。\n\n#### 3.9 图片 ####\n添加图片的形式和链接相似，只需在链接的基础上前方加一个`！`。\n#### 3.10 反斜杠`\\` ####\n相当于**反转义**作用。使符号成为普通符号。\n#### 3.11 符号'`' ####\n起到标记作用。如：\n>\\`ctrl+a\\`\n\n效果：\n>`ctrl+a`    \n\n#### 4. 都_谁_在用？####\nMarkdown的使用者：\n+ GitHub\n+ 简书\n+ Stack Overflow\n+ Apollo\n+ Moodle\n+ Reddit\n+ 等等\n\n#### 5. 感觉有意思？趁热打铁，推荐几个_工具_。 ####\n+ **Chrome**下的stackedit插件可以离线使用，很爽。也不用担心平台受限。\n在线的dillinger.io算是评价好的了，可是不能离线使用。    \n+ **Windowns**下的MarkdownPad也用过，不过免费版的体验不是很好。    \n+ **Mac**下的Mou是国人贡献的，口碑很好。推荐。    \n+ **Linux**下的ReText不错。    \n\n**其实在对语法了如于心的话，直接用编辑器就可以了，脑子里满满的都是格式化好的文本啊。**\n我现在使用`马克飞象` + `Markdown-here`，先编辑好，然后一键格式化，挺方便。\n\n****\n**注意**：不同的Markdown解释器或工具对相应语法（扩展语法）的解释效果不尽相同，具体可参见工具的使用说明。\n虽然有人想出面搞一个所谓的标准化的Markdown，[没想到还惹怒了健在的创始人John Gruber]\n(http://blog.codinghorror.com/standard-markdown-is-now-common-markdown/)。\n****\n以上基本是所有traditonal markdown的语法。\n\n### 其它： ###\n列表的使用(非traditonal markdown)：\n\n用`|`表示表格纵向边界，表头和表内容用`-`隔开，并可用`:`进行对齐设置，两边都有`:`则表示居中，若不加`:`则默认左对齐。\n\n|代码库                              |链接                                |\n|:------------------------------------:|------------------------------------|\n|MarkDown                              |[https://github.com/younghz/Markdown](https://github.com/younghz/Markdown \"Markdown\")|\n|moos-young                            |[https://github.com/younghz/moos-young](https://github.com/younghz/moos-young \"tianchi\")|\n\n关于其它扩展语法可参见具体工具的使用说明。\n\nModified based on :[younghz's Github](http://younghz.github.io/Markdown/)\n\n\n","slug":"Markdown语法","published":1,"updated":"2017-04-08T15:45:59.675Z","layout":"post","photos":[],"link":"","_id":"cj23iflz50008gola6qtrqmvu","content":"<h2 id=\"主要内容\"><a href=\"#主要内容\" class=\"headerlink\" title=\"主要内容\"></a>主要内容</h2><blockquote>\n<h4 id=\"Markdown是什么？\"><a href=\"#Markdown是什么？\" class=\"headerlink\" title=\"Markdown是什么？\"></a>Markdown是<em>什么</em>？</h4><h4 id=\"为什么要使用它？\"><a href=\"#为什么要使用它？\" class=\"headerlink\" title=\"为什么要使用它？\"></a><em>为什么</em>要使用它？</h4><h4 id=\"怎么使用？\"><a href=\"#怎么使用？\" class=\"headerlink\" title=\"怎么使用？\"></a><em>怎么</em>使用？</h4><h4 id=\"都谁在用？\"><a href=\"#都谁在用？\" class=\"headerlink\" title=\"都谁在用？\"></a>都<em>谁</em>在用？</h4><h4 id=\"感觉有意思？不怕你看见，就怕你试试\"><a href=\"#感觉有意思？不怕你看见，就怕你试试\" class=\"headerlink\" title=\"感觉有意思？不怕你看见，就怕你试试\"></a>感觉有意思？<em>不怕你看见，就怕你试试</em></h4><a id=\"more\"></a>\n</blockquote>\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><h3 id=\"1-Markdown是什么？\"><a href=\"#1-Markdown是什么？\" class=\"headerlink\" title=\"1. Markdown是什么？\"></a>1. Markdown是<em>什么</em>？</h3><p><strong>Markdown</strong>是一种轻量级<strong>标记语言</strong>，它以纯文本形式(<em>易读、易写、易更改</em>)编写文档，并最终以HTML格式发布。<br><strong>Markdown</strong>也可以理解为将以MARKDOWN语言编写的语言转换成HTML内容的工具，最初是一个perl脚本<em>Markdown.pl</em>。    </p>\n<h3 id=\"2-为什么要使用它？\"><a href=\"#2-为什么要使用它？\" class=\"headerlink\" title=\"2. 为什么要使用它？\"></a>2. <em>为什么</em>要使用它？</h3><ul>\n<li>它是易读（<em>看起开舒服</em>）、易写（<em>语法简单</em>）、易更改<strong>纯文本</strong>。处处体现着<strong>极简主义</strong>的影子。</li>\n<li>兼容HTML，可以转换为HTML格式发布。</li>\n<li>跨平台使用。</li>\n<li>越来越多的网站支持Markdown。</li>\n<li>更方便清晰的组织你的电子邮件。（Markdown-here, Airmail）</li>\n<li>摆脱Word（我不是认真的）。</li>\n</ul>\n<h3 id=\"3-怎么使用？\"><a href=\"#3-怎么使用？\" class=\"headerlink\" title=\"3. 怎么使用？\"></a>3. <em>怎么</em>使用？</h3><p>如果不算<strong>扩展</strong>，Markdown的语法绝对<strong>简单</strong>到让你爱不释手。</p>\n<p>废话太多，下面正文，Markdown语法主要分为如下几大部分：<br><strong>标题</strong>，<strong>段落</strong>，<strong>区块引用</strong>，<strong>代码区块</strong>，<strong>强调</strong>，<strong>列表</strong>，<strong>分割线</strong>，<strong>链接</strong>，<strong>图片</strong>，<strong>反斜杠 <code>\\</code></strong>，<strong>符号’`’</strong>。</p>\n<h4 id=\"3-1-标题\"><a href=\"#3-1-标题\" class=\"headerlink\" title=\"3.1 标题\"></a>3.1 标题</h4><p>两种形式：<br>1）使用<code>=</code>和<code>-</code>标记一级和二级标题。</p>\n<blockquote>\n<p>一级标题<br><code>=========</code><br>二级标题<br><code>---------</code></p>\n</blockquote>\n<p>效果：</p>\n<blockquote>\n<h1 id=\"一级标题\"><a href=\"#一级标题\" class=\"headerlink\" title=\"一级标题   \"></a>一级标题   </h1><h2 id=\"二级标题\"><a href=\"#二级标题\" class=\"headerlink\" title=\"二级标题\"></a>二级标题</h2></blockquote>\n<p>2）使用<code>#</code>，可表示1-6级标题。</p>\n<blockquote>\n<p># 一级标题<br>## 二级标题<br>### 三级标题<br>#### 四级标题<br>##### 五级标题<br>###### 六级标题    </p>\n</blockquote>\n<p>效果：</p>\n<blockquote>\n<h1 id=\"一级标题-1\"><a href=\"#一级标题-1\" class=\"headerlink\" title=\"一级标题\"></a>一级标题</h1><h2 id=\"二级标题-1\"><a href=\"#二级标题-1\" class=\"headerlink\" title=\"二级标题\"></a>二级标题</h2><h3 id=\"三级标题\"><a href=\"#三级标题\" class=\"headerlink\" title=\"三级标题\"></a>三级标题</h3><h4 id=\"四级标题\"><a href=\"#四级标题\" class=\"headerlink\" title=\"四级标题\"></a>四级标题</h4><h5 id=\"五级标题\"><a href=\"#五级标题\" class=\"headerlink\" title=\"五级标题\"></a>五级标题</h5><h6 id=\"六级标题\"><a href=\"#六级标题\" class=\"headerlink\" title=\"六级标题\"></a>六级标题</h6></blockquote>\n<h4 id=\"3-2-段落\"><a href=\"#3-2-段落\" class=\"headerlink\" title=\"3.2 段落\"></a>3.2 段落</h4><p>段落的前后要有空行，所谓的空行是指没有文字内容。若想在段内强制换行的方式是使用<strong>两个以上</strong>空格加上回车（引用中换行省略回车）。</p>\n<h4 id=\"3-3-区块引用\"><a href=\"#3-3-区块引用\" class=\"headerlink\" title=\"3.3 区块引用\"></a>3.3 区块引用</h4><p>在段落的每行或者只在第一行使用符号<code>&gt;</code>,还可使用多个嵌套引用，如：</p>\n<blockquote>\n<p>> 区块引用<br>>&gt; 嵌套引用  </p>\n</blockquote>\n<p>效果：</p>\n<blockquote>\n<p>区块引用  </p>\n<blockquote>\n<p>嵌套引用 </p>\n</blockquote>\n</blockquote>\n<h4 id=\"3-4-代码区块\"><a href=\"#3-4-代码区块\" class=\"headerlink\" title=\"3.4 代码区块\"></a>3.4 代码区块</h4><p>代码区块的建立是在每行加上4个空格或者一个制表符（如同写代码一样）。如<br>普通段落：</p>\n<p>void main()<br>{<br>    printf(“Hello, Markdown.”);<br>}    </p>\n<p>代码区块：</p>\n<pre><code>void main()\n{\n    printf(&quot;Hello, Markdown.&quot;);\n}\n</code></pre><p><strong>注意</strong>:需要和普通段落之间存在空行。</p>\n<h4 id=\"3-5-强调\"><a href=\"#3-5-强调\" class=\"headerlink\" title=\"3.5 强调\"></a>3.5 强调</h4><p>在强调内容两侧分别加上<code>*</code>或者<code>_</code>，如：</p>\n<blockquote>\n<p>*斜体*，_斜体_<br>**粗体**，__粗体__</p>\n</blockquote>\n<p>效果：</p>\n<blockquote>\n<p><em>斜体</em>，<em>斜体</em><br><strong>粗体</strong>，<strong>粗体</strong></p>\n</blockquote>\n<h4 id=\"3-6-列表\"><a href=\"#3-6-列表\" class=\"headerlink\" title=\"3.6 列表\"></a>3.6 列表</h4><p>使用<code>·</code>、<code>+</code>、或<code>-</code>标记无序列表，如：</p>\n<blockquote>\n<p>-（+*） 第一项<br>-（+*） 第二项<br>- （+*）第三项</p>\n</blockquote>\n<p><strong>注意</strong>：标记后面最少有一个<em>空格</em>或<em>制表符</em>。若不在引用区块中，必须和前方段落之间存在空行。</p>\n<p>效果：</p>\n<blockquote>\n<ul>\n<li>第一项</li>\n<li>第二项</li>\n<li>第三项</li>\n</ul>\n</blockquote>\n<p>有序列表的标记方式是将上述的符号换成数字,并辅以<code>.</code>，如：</p>\n<blockquote>\n<p>1 . 第一项<br>2 . 第二项<br>3 . 第三项    </p>\n</blockquote>\n<p>效果：</p>\n<blockquote>\n<ol>\n<li>第一项</li>\n<li>第二项</li>\n<li>第三项</li>\n</ol>\n</blockquote>\n<h4 id=\"3-7-分割线\"><a href=\"#3-7-分割线\" class=\"headerlink\" title=\"3.7 分割线\"></a>3.7 分割线</h4><p>分割线最常使用就是三个或以上<code>*</code>，还可以使用<code>-</code>和<code>_</code>。</p>\n<h4 id=\"3-8-链接\"><a href=\"#3-8-链接\" class=\"headerlink\" title=\"3.8 链接\"></a>3.8 链接</h4><p>链接可以由两种形式生成：<strong>行内式</strong>和<strong>参考式</strong>。<br><strong>行内式</strong>：</p>\n<blockquote>\n<p>[younghz的Markdown库](https:://github.com/younghz/Markdown “Markdown”)。</p>\n</blockquote>\n<p>效果：</p>\n<blockquote>\n<p><a href=\"https:://github.com/younghz/Markdown\" title=\"Markdown\" target=\"_blank\" rel=\"external\">younghz的Markdown库</a>。</p>\n</blockquote>\n<p><strong>参考式</strong>：</p>\n<blockquote>\n<p>[younghz的Markdown库1][1]<br>[younghz的Markdown库2][2]<br>[1]:https:://github.com/younghz/Markdown “Markdown”<br>[2]:https:://github.com/younghz/Markdown “Markdown”    </p>\n</blockquote>\n<p>效果：</p>\n<blockquote>\n<p><a href=\"https:://github.com/younghz/Markdown\" title=\"Markdown\" target=\"_blank\" rel=\"external\">younghz的Markdown库1</a><br><a href=\"https:://github.com/younghz/Markdown\" title=\"Markdown\" target=\"_blank\" rel=\"external\">younghz的Markdown库2</a></p>\n</blockquote>\n<p><strong>注意</strong>：上述的<code>[1]:https:://github.com/younghz/Markdown &quot;Markdown&quot;</code>不出现在区块中。</p>\n<h4 id=\"3-9-图片\"><a href=\"#3-9-图片\" class=\"headerlink\" title=\"3.9 图片\"></a>3.9 图片</h4><p>添加图片的形式和链接相似，只需在链接的基础上前方加一个<code>！</code>。</p>\n<h4 id=\"3-10-反斜杠\"><a href=\"#3-10-反斜杠\" class=\"headerlink\" title=\"3.10 反斜杠\\\"></a>3.10 反斜杠<code>\\</code></h4><p>相当于<strong>反转义</strong>作用。使符号成为普通符号。</p>\n<h4 id=\"3-11-符号’-’\"><a href=\"#3-11-符号’-’\" class=\"headerlink\" title=\"3.11 符号’`’\"></a>3.11 符号’`’</h4><p>起到标记作用。如：</p>\n<blockquote>\n<p>`ctrl+a`</p>\n</blockquote>\n<p>效果：</p>\n<blockquote>\n<p><code>ctrl+a</code>    </p>\n</blockquote>\n<h4 id=\"4-都谁在用？\"><a href=\"#4-都谁在用？\" class=\"headerlink\" title=\"4. 都谁在用？\"></a>4. 都<em>谁</em>在用？</h4><p>Markdown的使用者：</p>\n<ul>\n<li>GitHub</li>\n<li>简书</li>\n<li>Stack Overflow</li>\n<li>Apollo</li>\n<li>Moodle</li>\n<li>Reddit</li>\n<li>等等</li>\n</ul>\n<h4 id=\"5-感觉有意思？趁热打铁，推荐几个工具。\"><a href=\"#5-感觉有意思？趁热打铁，推荐几个工具。\" class=\"headerlink\" title=\"5. 感觉有意思？趁热打铁，推荐几个工具。\"></a>5. 感觉有意思？趁热打铁，推荐几个<em>工具</em>。</h4><ul>\n<li><strong>Chrome</strong>下的stackedit插件可以离线使用，很爽。也不用担心平台受限。<br>在线的dillinger.io算是评价好的了，可是不能离线使用。    </li>\n<li><strong>Windowns</strong>下的MarkdownPad也用过，不过免费版的体验不是很好。    </li>\n<li><strong>Mac</strong>下的Mou是国人贡献的，口碑很好。推荐。    </li>\n<li><strong>Linux</strong>下的ReText不错。    </li>\n</ul>\n<p><strong>其实在对语法了如于心的话，直接用编辑器就可以了，脑子里满满的都是格式化好的文本啊。</strong><br>我现在使用<code>马克飞象</code> + <code>Markdown-here</code>，先编辑好，然后一键格式化，挺方便。</p>\n<hr>\n<p><strong>注意</strong>：不同的Markdown解释器或工具对相应语法（扩展语法）的解释效果不尽相同，具体可参见工具的使用说明。<br>虽然有人想出面搞一个所谓的标准化的Markdown，[没想到还惹怒了健在的创始人John Gruber]<br>(<a href=\"http://blog.codinghorror.com/standard-markdown-is-now-common-markdown/)。\" target=\"_blank\" rel=\"external\">http://blog.codinghorror.com/standard-markdown-is-now-common-markdown/)。</a></p>\n<hr>\n<p>以上基本是所有traditonal markdown的语法。</p>\n<h3 id=\"其它：\"><a href=\"#其它：\" class=\"headerlink\" title=\"其它：\"></a>其它：</h3><p>列表的使用(非traditonal markdown)：</p>\n<p>用<code>|</code>表示表格纵向边界，表头和表内容用<code>-</code>隔开，并可用<code>:</code>进行对齐设置，两边都有<code>:</code>则表示居中，若不加<code>:</code>则默认左对齐。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">代码库</th>\n<th>链接</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">MarkDown</td>\n<td><a href=\"https://github.com/younghz/Markdown\" title=\"Markdown\" target=\"_blank\" rel=\"external\">https://github.com/younghz/Markdown</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">moos-young</td>\n<td><a href=\"https://github.com/younghz/moos-young\" title=\"tianchi\" target=\"_blank\" rel=\"external\">https://github.com/younghz/moos-young</a></td>\n</tr>\n</tbody>\n</table>\n<p>关于其它扩展语法可参见具体工具的使用说明。</p>\n<p>Modified based on :<a href=\"http://younghz.github.io/Markdown/\" target=\"_blank\" rel=\"external\">younghz’s Github</a></p>\n","excerpt":"<h2 id=\"主要内容\"><a href=\"#主要内容\" class=\"headerlink\" title=\"主要内容\"></a>主要内容</h2><blockquote>\n<h4 id=\"Markdown是什么？\"><a href=\"#Markdown是什么？\" class=\"headerlink\" title=\"Markdown是什么？\"></a>Markdown是<em>什么</em>？</h4><h4 id=\"为什么要使用它？\"><a href=\"#为什么要使用它？\" class=\"headerlink\" title=\"为什么要使用它？\"></a><em>为什么</em>要使用它？</h4><h4 id=\"怎么使用？\"><a href=\"#怎么使用？\" class=\"headerlink\" title=\"怎么使用？\"></a><em>怎么</em>使用？</h4><h4 id=\"都谁在用？\"><a href=\"#都谁在用？\" class=\"headerlink\" title=\"都谁在用？\"></a>都<em>谁</em>在用？</h4><h4 id=\"感觉有意思？不怕你看见，就怕你试试\"><a href=\"#感觉有意思？不怕你看见，就怕你试试\" class=\"headerlink\" title=\"感觉有意思？不怕你看见，就怕你试试\"></a>感觉有意思？<em>不怕你看见，就怕你试试</em></h4></blockquote>","more":"\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><h3 id=\"1-Markdown是什么？\"><a href=\"#1-Markdown是什么？\" class=\"headerlink\" title=\"1. Markdown是什么？\"></a>1. Markdown是<em>什么</em>？</h3><p><strong>Markdown</strong>是一种轻量级<strong>标记语言</strong>，它以纯文本形式(<em>易读、易写、易更改</em>)编写文档，并最终以HTML格式发布。<br><strong>Markdown</strong>也可以理解为将以MARKDOWN语言编写的语言转换成HTML内容的工具，最初是一个perl脚本<em>Markdown.pl</em>。    </p>\n<h3 id=\"2-为什么要使用它？\"><a href=\"#2-为什么要使用它？\" class=\"headerlink\" title=\"2. 为什么要使用它？\"></a>2. <em>为什么</em>要使用它？</h3><ul>\n<li>它是易读（<em>看起开舒服</em>）、易写（<em>语法简单</em>）、易更改<strong>纯文本</strong>。处处体现着<strong>极简主义</strong>的影子。</li>\n<li>兼容HTML，可以转换为HTML格式发布。</li>\n<li>跨平台使用。</li>\n<li>越来越多的网站支持Markdown。</li>\n<li>更方便清晰的组织你的电子邮件。（Markdown-here, Airmail）</li>\n<li>摆脱Word（我不是认真的）。</li>\n</ul>\n<h3 id=\"3-怎么使用？\"><a href=\"#3-怎么使用？\" class=\"headerlink\" title=\"3. 怎么使用？\"></a>3. <em>怎么</em>使用？</h3><p>如果不算<strong>扩展</strong>，Markdown的语法绝对<strong>简单</strong>到让你爱不释手。</p>\n<p>废话太多，下面正文，Markdown语法主要分为如下几大部分：<br><strong>标题</strong>，<strong>段落</strong>，<strong>区块引用</strong>，<strong>代码区块</strong>，<strong>强调</strong>，<strong>列表</strong>，<strong>分割线</strong>，<strong>链接</strong>，<strong>图片</strong>，<strong>反斜杠 <code>\\</code></strong>，<strong>符号’`’</strong>。</p>\n<h4 id=\"3-1-标题\"><a href=\"#3-1-标题\" class=\"headerlink\" title=\"3.1 标题\"></a>3.1 标题</h4><p>两种形式：<br>1）使用<code>=</code>和<code>-</code>标记一级和二级标题。</p>\n<blockquote>\n<p>一级标题<br><code>=========</code><br>二级标题<br><code>---------</code></p>\n</blockquote>\n<p>效果：</p>\n<blockquote>\n<h1 id=\"一级标题\"><a href=\"#一级标题\" class=\"headerlink\" title=\"一级标题   \"></a>一级标题   </h1><h2 id=\"二级标题\"><a href=\"#二级标题\" class=\"headerlink\" title=\"二级标题\"></a>二级标题</h2></blockquote>\n<p>2）使用<code>#</code>，可表示1-6级标题。</p>\n<blockquote>\n<p># 一级标题<br>## 二级标题<br>### 三级标题<br>#### 四级标题<br>##### 五级标题<br>###### 六级标题    </p>\n</blockquote>\n<p>效果：</p>\n<blockquote>\n<h1 id=\"一级标题-1\"><a href=\"#一级标题-1\" class=\"headerlink\" title=\"一级标题\"></a>一级标题</h1><h2 id=\"二级标题-1\"><a href=\"#二级标题-1\" class=\"headerlink\" title=\"二级标题\"></a>二级标题</h2><h3 id=\"三级标题\"><a href=\"#三级标题\" class=\"headerlink\" title=\"三级标题\"></a>三级标题</h3><h4 id=\"四级标题\"><a href=\"#四级标题\" class=\"headerlink\" title=\"四级标题\"></a>四级标题</h4><h5 id=\"五级标题\"><a href=\"#五级标题\" class=\"headerlink\" title=\"五级标题\"></a>五级标题</h5><h6 id=\"六级标题\"><a href=\"#六级标题\" class=\"headerlink\" title=\"六级标题\"></a>六级标题</h6></blockquote>\n<h4 id=\"3-2-段落\"><a href=\"#3-2-段落\" class=\"headerlink\" title=\"3.2 段落\"></a>3.2 段落</h4><p>段落的前后要有空行，所谓的空行是指没有文字内容。若想在段内强制换行的方式是使用<strong>两个以上</strong>空格加上回车（引用中换行省略回车）。</p>\n<h4 id=\"3-3-区块引用\"><a href=\"#3-3-区块引用\" class=\"headerlink\" title=\"3.3 区块引用\"></a>3.3 区块引用</h4><p>在段落的每行或者只在第一行使用符号<code>&gt;</code>,还可使用多个嵌套引用，如：</p>\n<blockquote>\n<p>> 区块引用<br>>&gt; 嵌套引用  </p>\n</blockquote>\n<p>效果：</p>\n<blockquote>\n<p>区块引用  </p>\n<blockquote>\n<p>嵌套引用 </p>\n</blockquote>\n</blockquote>\n<h4 id=\"3-4-代码区块\"><a href=\"#3-4-代码区块\" class=\"headerlink\" title=\"3.4 代码区块\"></a>3.4 代码区块</h4><p>代码区块的建立是在每行加上4个空格或者一个制表符（如同写代码一样）。如<br>普通段落：</p>\n<p>void main()<br>{<br>    printf(“Hello, Markdown.”);<br>}    </p>\n<p>代码区块：</p>\n<pre><code>void main()\n{\n    printf(&quot;Hello, Markdown.&quot;);\n}\n</code></pre><p><strong>注意</strong>:需要和普通段落之间存在空行。</p>\n<h4 id=\"3-5-强调\"><a href=\"#3-5-强调\" class=\"headerlink\" title=\"3.5 强调\"></a>3.5 强调</h4><p>在强调内容两侧分别加上<code>*</code>或者<code>_</code>，如：</p>\n<blockquote>\n<p>*斜体*，_斜体_<br>**粗体**，__粗体__</p>\n</blockquote>\n<p>效果：</p>\n<blockquote>\n<p><em>斜体</em>，<em>斜体</em><br><strong>粗体</strong>，<strong>粗体</strong></p>\n</blockquote>\n<h4 id=\"3-6-列表\"><a href=\"#3-6-列表\" class=\"headerlink\" title=\"3.6 列表\"></a>3.6 列表</h4><p>使用<code>·</code>、<code>+</code>、或<code>-</code>标记无序列表，如：</p>\n<blockquote>\n<p>-（+*） 第一项<br>-（+*） 第二项<br>- （+*）第三项</p>\n</blockquote>\n<p><strong>注意</strong>：标记后面最少有一个<em>空格</em>或<em>制表符</em>。若不在引用区块中，必须和前方段落之间存在空行。</p>\n<p>效果：</p>\n<blockquote>\n<ul>\n<li>第一项</li>\n<li>第二项</li>\n<li>第三项</li>\n</ul>\n</blockquote>\n<p>有序列表的标记方式是将上述的符号换成数字,并辅以<code>.</code>，如：</p>\n<blockquote>\n<p>1 . 第一项<br>2 . 第二项<br>3 . 第三项    </p>\n</blockquote>\n<p>效果：</p>\n<blockquote>\n<ol>\n<li>第一项</li>\n<li>第二项</li>\n<li>第三项</li>\n</ol>\n</blockquote>\n<h4 id=\"3-7-分割线\"><a href=\"#3-7-分割线\" class=\"headerlink\" title=\"3.7 分割线\"></a>3.7 分割线</h4><p>分割线最常使用就是三个或以上<code>*</code>，还可以使用<code>-</code>和<code>_</code>。</p>\n<h4 id=\"3-8-链接\"><a href=\"#3-8-链接\" class=\"headerlink\" title=\"3.8 链接\"></a>3.8 链接</h4><p>链接可以由两种形式生成：<strong>行内式</strong>和<strong>参考式</strong>。<br><strong>行内式</strong>：</p>\n<blockquote>\n<p>[younghz的Markdown库](https:://github.com/younghz/Markdown “Markdown”)。</p>\n</blockquote>\n<p>效果：</p>\n<blockquote>\n<p><a href=\"https:://github.com/younghz/Markdown\" title=\"Markdown\">younghz的Markdown库</a>。</p>\n</blockquote>\n<p><strong>参考式</strong>：</p>\n<blockquote>\n<p>[younghz的Markdown库1][1]<br>[younghz的Markdown库2][2]<br>[1]:https:://github.com/younghz/Markdown “Markdown”<br>[2]:https:://github.com/younghz/Markdown “Markdown”    </p>\n</blockquote>\n<p>效果：</p>\n<blockquote>\n<p><a href=\"https:://github.com/younghz/Markdown\" title=\"Markdown\">younghz的Markdown库1</a><br><a href=\"https:://github.com/younghz/Markdown\" title=\"Markdown\">younghz的Markdown库2</a></p>\n</blockquote>\n<p><strong>注意</strong>：上述的<code>[1]:https:://github.com/younghz/Markdown &quot;Markdown&quot;</code>不出现在区块中。</p>\n<h4 id=\"3-9-图片\"><a href=\"#3-9-图片\" class=\"headerlink\" title=\"3.9 图片\"></a>3.9 图片</h4><p>添加图片的形式和链接相似，只需在链接的基础上前方加一个<code>！</code>。</p>\n<h4 id=\"3-10-反斜杠\"><a href=\"#3-10-反斜杠\" class=\"headerlink\" title=\"3.10 反斜杠\\\"></a>3.10 反斜杠<code>\\</code></h4><p>相当于<strong>反转义</strong>作用。使符号成为普通符号。</p>\n<h4 id=\"3-11-符号’-’\"><a href=\"#3-11-符号’-’\" class=\"headerlink\" title=\"3.11 符号’`’\"></a>3.11 符号’`’</h4><p>起到标记作用。如：</p>\n<blockquote>\n<p>`ctrl+a`</p>\n</blockquote>\n<p>效果：</p>\n<blockquote>\n<p><code>ctrl+a</code>    </p>\n</blockquote>\n<h4 id=\"4-都谁在用？\"><a href=\"#4-都谁在用？\" class=\"headerlink\" title=\"4. 都谁在用？\"></a>4. 都<em>谁</em>在用？</h4><p>Markdown的使用者：</p>\n<ul>\n<li>GitHub</li>\n<li>简书</li>\n<li>Stack Overflow</li>\n<li>Apollo</li>\n<li>Moodle</li>\n<li>Reddit</li>\n<li>等等</li>\n</ul>\n<h4 id=\"5-感觉有意思？趁热打铁，推荐几个工具。\"><a href=\"#5-感觉有意思？趁热打铁，推荐几个工具。\" class=\"headerlink\" title=\"5. 感觉有意思？趁热打铁，推荐几个工具。\"></a>5. 感觉有意思？趁热打铁，推荐几个<em>工具</em>。</h4><ul>\n<li><strong>Chrome</strong>下的stackedit插件可以离线使用，很爽。也不用担心平台受限。<br>在线的dillinger.io算是评价好的了，可是不能离线使用。    </li>\n<li><strong>Windowns</strong>下的MarkdownPad也用过，不过免费版的体验不是很好。    </li>\n<li><strong>Mac</strong>下的Mou是国人贡献的，口碑很好。推荐。    </li>\n<li><strong>Linux</strong>下的ReText不错。    </li>\n</ul>\n<p><strong>其实在对语法了如于心的话，直接用编辑器就可以了，脑子里满满的都是格式化好的文本啊。</strong><br>我现在使用<code>马克飞象</code> + <code>Markdown-here</code>，先编辑好，然后一键格式化，挺方便。</p>\n<hr>\n<p><strong>注意</strong>：不同的Markdown解释器或工具对相应语法（扩展语法）的解释效果不尽相同，具体可参见工具的使用说明。<br>虽然有人想出面搞一个所谓的标准化的Markdown，[没想到还惹怒了健在的创始人John Gruber]<br>(<a href=\"http://blog.codinghorror.com/standard-markdown-is-now-common-markdown/)。\">http://blog.codinghorror.com/standard-markdown-is-now-common-markdown/)。</a></p>\n<hr>\n<p>以上基本是所有traditonal markdown的语法。</p>\n<h3 id=\"其它：\"><a href=\"#其它：\" class=\"headerlink\" title=\"其它：\"></a>其它：</h3><p>列表的使用(非traditonal markdown)：</p>\n<p>用<code>|</code>表示表格纵向边界，表头和表内容用<code>-</code>隔开，并可用<code>:</code>进行对齐设置，两边都有<code>:</code>则表示居中，若不加<code>:</code>则默认左对齐。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">代码库</th>\n<th>链接</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">MarkDown</td>\n<td><a href=\"https://github.com/younghz/Markdown\" title=\"Markdown\">https://github.com/younghz/Markdown</a></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">moos-young</td>\n<td><a href=\"https://github.com/younghz/moos-young\" title=\"tianchi\">https://github.com/younghz/moos-young</a></td>\n</tr>\n</tbody>\n</table>\n<p>关于其它扩展语法可参见具体工具的使用说明。</p>\n<p>Modified based on :<a href=\"http://younghz.github.io/Markdown/\">younghz’s Github</a></p>"},{"title":"使用Hexo和GitHub Pages搭建免费独立博客及域名配置","date":"2016-11-11T08:31:52.000Z","toc":true,"_content":"\n\n摘要：这是一篇使用GitHub Pages和Hexo搭建免费独立博客的总结。\n\n我在这里写下长篇大论，只希望小白们能更快速入门。一天搭建出属于自己的个人独立博客，我将会通过 安装流程主线+优质文章 作为参考。从我个人接触到成功搭建博客，走了很多弯路，网上的资料更是琳琅满目无从下手，希望通过本教程给想搭建个人博客的人一个敢于尝试的机会。我会将这篇教程写仔细，会将我出现过的问题给予解决方法。大家有问题可以留言，我会尽量帮助大家解决。\n\n\n\n\n# 前言\n为什么选择GitHub Pages？\n> * 无需购置服务器，目前的blog挂载在Github Pages，免服务器费的同时还能做负载均衡;\n* github pages有300M免费空间，资料自己管理，保存可靠；\n* 学着用github，享受github的便利，上面有很多大牛，眼界会开阔很多；\n* 顺便看看github工作原理，最好的团队协作流程；\n* github是趋势；\n\n\n<!--more-->\n\n# 准备工作\n相信自己，敢于面对，过程并不是很难。\n\n## Nodejs环境包\n\n因为 Hexo 是基于 Node.js 的第三方模块，所以缺少 Node.js 不可。访问 [Node.js官网](http://nodejs.org/)下载适合自己系统的 Node.js 安装包。目前最新的版本为 ｖ6.5.0。\n\n（注：至于安装过程和环境变量配置请参考[菜鸟教程-Node.js安装配置](http://www.runoob.com/nodejs/nodejs-install-setup.html)）\n\n## Git工具包\n\n如果之后你需要安装一些 Hexo 的主题和插件，[Git](https://git-scm.com/downloads/) 是最好的下载方式。因为好多主题都被放在了 Github 上，你只需要敲几个字符就可以下载。\n\n（注：宁浩网之前介绍过Git的使用方法，安装过程及简单使用请见[这里](http://ninghao.net/blog/1379)）\n\n### Git与GitHub区别\n\n这里，我们要区分清楚git与github。\ngit是一个版本控制的工具，而github有点类似于远程仓库，用于存放用git管理的各种项目。\n\n### 与GitHub建立联系\n\ngit安装好以后执行以下步骤：\n> 1. 从程序目录打开 \"Git Bash\" ,或者直接用git shell，github自带的工具\n2. 键入命令：ssh-keygen -t rsa -C \"email@email.com\"\n  \"email@email.com\"是github注册账号邮箱地址\n3. 提醒你输入key的名称，你可以不用输入，直接3个回车，就OK了；\n4. 在C:\\Documents and Settings\\Administrator\\下产生两个文件：id_rsa和id_rsa.pub\n5. 用记事本打开id_rsa.pub文件，复制内容，在github的网站上找到ssh密钥管理页面，添加新公钥 。\n6. 在git bash中输入ssh -T git@github.com命令，出现Hi username! You've successfully authenticated表示成功。\n\n### 设置用户信息\n\n现在你已经可以通过 SSH 链接到 GitHub 了，还有一些个人信息需要完善的。\n\nGit 会根据用户的名字和邮箱来记录提交。GitHub 也是用这些信息来做权限的处理，输入下面的代码进行个人信息的设置，把名称和邮箱替换成你自己的，名字必须是你的真名，而不是GitHub的昵称。\n```\n$ git config --global user.name \"***\"//用户名\n$ git config --global user.email \"****@****.com\"//填写自己的邮箱\n```\n\n# 开始搭建\n\n因为最终博客是要部署到github上的，这里我首先讲解github建立仓库，然后讲解hexo安装。为了方便大家一次部署成功并且考虑到以后如果大家换电脑或者重装系统后还能够修改以前的博客，请按照我的解决方案进行，这里大家不懂也没事，照着来就行，我会在文章末尾优化部署与管理中详解。\n\n## 创建GitHub Pages 仓库\n\n在自己的GitHub账号下创建一个新的仓库，命名为username.github.io\n（username是你的账号名)。在这里，要知道，GitHub Pages有两种类型：User/Organization Pages 和 Project Pages，而我所使用的是User Pages。\n简单来说，User Pages 与 Project Pages的区别是：\n> * User Pages 是用来展示用户的，而 Project Pages 是用来展示项目的。\n* 用于存放 User Pages 的仓库必须使用username.github.io的命名规则，而 Project Pages 则没有特殊的要求。\n* User Pages 将使用仓库的 master 分支，而 Project Pages 将使用 gh-pages 分支。\n* User Pages 通过 http(s)://username.github.io 进行访问，而 Projects * Pages通过 http(s)://username.github.io/projectname 进行访问。\n\n** 这一步很关键 **\n创建两个分支：master 与 hexo。** 设置hexo为默认分支 **（因为我们只需要手动管理这个分支上的Hexo网站文件）\n\n到这为止，我们的github仓库已经建立好了，我们马上就能见到成果了，下面我们开始建站。\n## hexo介绍\nHexo 是一个轻量的静态博客框架。通过Hexo可以快速生成一个静态博客框架,仅需要几条命令就可以完成,相当方便。\n\n而架设Hexo的环境更简单了 不需要 lnmp/lamp/XAMPP 这些繁琐复杂的环境 仅仅需要一个简单的http服务器即可使用 或者使用互联网上免费的页面托管服务\n\n比如本人的这个博客 就是托管于 GitHub Pages服务上\n## hexo安装\n安装Hexo相当简单。在安装之前，必须检查电脑中是否已经安装下列应用程序：\n* [Node.js](http://nodejs.org/)\n* [Git](http://git-scm.com/)\n\n如果您的电脑中已经安装上述必备程序，那么恭喜您！接下来只需要使用 npm 即可完成 Hexo 的安装。打开git bash执行以下命令：\n```\n$ npm install -g hexo-cli\n```\n这样hexo就已经安装好了。\n\n## 使用hexo建站\n\n安装完后，在你喜欢的文件夹内（我的是根目录）（例如H：\\），点击鼠标右键选择Git bash，输入以下指令（填自己的地址）：\n``` \ngit clone git@github.com:username/username.github.io.git \n```\n\n该命令会把你的博客仓库同步下来，然后cd到你的仓库文件夹下面依次执行以下命令：\n> 1、$ hexo init\n\n该命令会在目标文件夹内建立网站所需要的所有文件。接下来是安装依赖包：\n> 2、$ npm install\n\n这样，我们就已经搭建起本地的Hexo博客了。可以先执行以下命令（在对应文件夹下），然后再浏览器输入localhost:4000查看。\n> 3、$ hexo generate\n> 4、$ hexo server\n\n这个博客只是本地的，别人是浏览不了的，之后需要部署到GitHub上。\n\n### 相关资料\n\n* [Hexo 官方文档](https://hexo.io/zh-cn/docs/)\n\n## 部署博客到GitHub上\n\n部署其实很简单，只要改一下配置文件，执行几条命令就行了，为了以后的方便，现在麻烦了一点，大家跟着做就行了，具体原因也在配置管理与优化里有讲到。\n\n### 配置站点文件\n\n我们继续使用上面的文件夹H:\\username.github.io（也可以新建一个文件夹重新生成），然后编辑该文件夹下的_config.yml（这是站点配置文件）\n默认生成的_config.yml：\n``` \n# Deployment \n## Docs: http://hexo.io/docs/deployment.html \ndeploy:   \n  type:\n```\n修改后的_config.yml：（也是填入自己的ssh地址）\n``` \ndeploy:\n  type: git\n  repository: git@github.com:username/username.github.io.git\n  branch: master\n```\n这里解释一下前面为什么建立两个分支master和hexo，为了管理方便，以后master分支用来发布网站（一会再说怎么发布），hexo分支用来存放Hexo网站文件。\n### 发布\n为了能够使Hexo部署到GitHub上，需要安装一个插件：（在项目目录下执行命令）\n``` \n$ npm install hexo-deployer-git --save \n```\n然后，执行下列指令即可完成部署：（以后发布也按照这三条命令执行）\n``` \n$ hexo clean #清空public文件夹下生成的静态文件和db.json文件\n$ hexo generate #重新生成静态文件和db.json\n$ hexo deploy #按照站点配置文件部署到github上\n```\n之后，可以通过在浏览器键入：username.github.io进行浏览，开心吧~\n\n### 提交Hexo网站文件到hexo分支\n\n由于上面执行了hexo init命令，所以要重新关联远端库\n首先在项目文件夹下执行以下命令：\n``` \n$ git init #初始化为一个git目录\n$ git remote add origin git@github.com:username/username.github.io.git #使用你自己的地址关联\n$ git pull #pull一下你的远端库\n```\n此时你应该在hexo分支下，如下：\n``` \n$ H:\\username.github.io (hexo) (hexo-site@0.0.0)\n```\n如果不是，执行以下命令切换到hexo分支：\n``` \n$ git checkout hexo \n```\n然后执行以下命令提交网站相关文件：\n```\n$ git add . #添加所有文件到暂存区\n$ git commit -m \"提交信息\"     #提交到本地仓库\n$ git push origin hexo  #把本地库push到远端库的hexo分支\n```\n提交后去github上查看是否成功，这是我的[github地址](https://github.com/username/username.github.io)，看看是否一样。\n## 更换主题\n\n我使用的是[next主题]()，大家喜欢也可以去我的[github](https://github.com/username/username.github.io)上fork一下，然后在这基础上修改，大家也可以找自己喜欢的主题来换。\n如果想要使用其他主题，可以使用git clone将别人的主题拷贝到H:\\username.github.io\\themes下，然后将_config.yml中的theme: landscape改为对应的主题名字。\n下面以切换next主题为例来讲一下具体如何操作，同样也是在项目文件夹下执行以下命令：\n```\n$ git clone https://github.com/iissnan/hexo-theme-next.git themes/next\n```\n然后在站点配置文件_config.yml中的theme: landscape改为theme: next，重新发布一下就完成了。\n### 相关资料\n* [next主题使用文档](http://theme-next.iissnan.com/)\n\n\n# 优化部署与管理\n## 概述\nHexo部署到GitHub上的文件，是.md（你的博文）转化之后的.html（静态网页）。因此，当你重装电脑或者想在不同电脑上修改博客时，就不可能了（除非你自己写html）。\n其实，Hexo生成的网站文件中有.gitignore文件，因此它的本意也是想我们将Hexo生成的网站文件存放到GitHub上进行管理的（而不是用U盘或者云备份啦。）这样，不仅解决了上述的问题，还可以通过git的版本控制追踪你的博文的修改过程，是极赞的。\n但是，如果每一个GitHub Pages都需要创建一个额外的仓库来存放Hexo网站文件，我感觉很麻烦（10个项目需要20个仓库）。\n所以，我利用了分支！！！\n简单地说，每个想建立GitHub Pages的仓库，起码有两个分支，一个用来存放Hexo网站的文件，一个用来发布网站。\n下面以我的博客作为例子详细地讲述。\n### 我的博客搭建流程\n> 1、创建仓库，username.github.io；\n2、创建两个分支：master 与 hexo；\n3、设置hexo为默认分支（因为我们只需要手动管理这个分支上的Hexo网站文件）；\n4、使用git clone git@github.com:username/username.github.io.git拷贝仓库；\n5、在本地username.github.io文件夹下通过Git bash依次执行npm install hexo-cli、hexo init、npm install 和 npm install hexo-deployer-git（此时当前分支应显示为hexo）;\n6、修改_config.yml中的deploy参数，分支应为master；\n7、使用git init 、\ngit remote add origin git@github.com:username/username.github.io.git以及git pull命令重新关联远端库。\n8、使用git checkout hexo命令切换到hexo分支然后依次执行git add .、git commit -m “…”、git push origin hexo提交网站相关的文件；\n9、执行hexo g、 hexo d生成网站并部署到GitHub上。\n\n### shell脚本自动化\n开启 Hexo 的本地服务或者提交到github pages这些都是一些终端里的 Hexo 命令，所以笔者写了一些 shell 脚本，来简化这些操作。所以基本就是用 hey 可视化写文章，写好了之后，然后点击 一键部署 的 shell 脚本，然后就自动发布了（当然这也纯属鸡助，看个人。）。由于 shell 脚本比较简单，在此插入一个一键部署的shell脚本代码。\n```\n#!/bin/sh\ncd /your/path \nhexo clean\nhexo g\nhexo d\ngit add .\ngit commit -m \"modified\"\ngit push origin hexo\n```\n这样一来，在GitHub上的username.github.io仓库就有两个分支，一个hexo分支用来存放网站的原始文件，一个master分支用来存放生成的静态网页。完美！\n## 我的博客管理流程\n### 日常修改\n在本地对博客进行修改（添加新博文、修改样式等等）后，通过下面的流程进行管理：\n依次执行git add .、git commit -m “…”、git push origin hexo指令将改动推送到GitHub（此时当前分支应为hexo）；\n然后才执行hexo generate -d发布网站到master分支上。\n。\n### 本地资料丢失\n当重装电脑之后，或者想在其他电脑上修改博客，可以使用下列步骤：\n> 1、使用git clone git@github.com:username/username.github.io.git拷贝仓库（默认分支为hexo）；\n2、在本地新拷贝的username.github.io文件夹下通过Git bash依次执行下列指令：npm install hexo-cli、npm install、npm install hexo-deployer-git（记得，不需要hexo init这条指令）。\n\n# 购买域名及配置\n## 综述\n因为Hexo个人博客是托管在github之上，每次访问都要使用githubname.github.io这么一个长串的域名来访问，会显得非常繁琐。这个时候我们可以购买一个域名，设置DNS跳转，以达到通过域名即可访问我们的个人博客。通过查阅文档发现，github pages是支持域名绑定的。\n## 购买域名\n国内国外有很多的域名供应商，选择一个好的机构购买域名，会为自己的站点配置节约很多时间，也不会因为域名的出错，导致影响百度对我们个人博客的收录。近几年来，国内做的比较好的域名供应商有阿里的万网。我就是在阿里的[万网](https://wanwang.aliyun.com/)购买的域名。通过查找，找到自己喜欢的域名，后来为了解决成本，我选了.top结尾的域名，一年只需要4块钱，很便宜。\n## 域名配置\n~~### DNS地址解析\n修改域名的 DNS 地址为 f1g1ns1.dnspod.net 和 f1g1ns2.dnspod.net~~ \n### 域名解析\n~~登录进入万网的域名控制台，点击\"域名和网站\"中的\"云DNS\"，点击对应域名的\"解析\"。\n点击添加解析，记录类型选A或CNAME，A记录的记录值就是ip地址，github(官方文档)提供了两个IP地址，192.30.252.153和192.30.252.154，这两个IP地址为github的服务器地址，两个都要填上，解析记录设置两个www和@，线路就默认就行了（或ping自己的xx.github.io），CNAME记录值填你的github博客网址。如我的是sidney001.github.io。\n这些全部设置完成后，此时你并不能要申请的域名访问你的博客。接着你需要做的是在hexo根目录的source文件夹里创建CNAME文件，不带任何后缀，里面添加你的域名信息，如：sidney001.top。实践证明用www.sidney001.top和sidney001.top访问都是可以的。重新清理hexo,并发布即可用新的域名访问。~~\n\n在阿里云管理控制台中,选择中刚刚购买的域名,点击解析按钮\n这时会提醒你选择解析到阿里云主机,或者其他主机,这时需要将你在GitHub上创建的GitHub Pages的域名 xxx.github.io进行查询,得到一个IP地址。\n\n从ping指令得到一个IP地址 151.101.100.133, 将这个IP地址记录下来\n进入万网【域名控制台】》【域名解析】标签,选择【解析设置】,\n点击【添加设置】,添加一个记录类型为A,主机记录为www,解析线路默认,记录值为151.101.100.133的记录\n点击【添加设置】,再添加一个记录类型为A,主机记录为@,解析线路默认,记录值为151.101.100.133的记录。\n### Github 解析\n在GitHub的xxx.github.io项目,进入【Settings】标签页,在【Custom domain】功能中,将刚刚申请的域名写进去。\n\nGitHub设置完成,等几分钟,在浏览器输入刚刚购买的域名,就可以看到刚刚GitHub上的网站了!\n\n\n# 结尾\n在网上看了很多资料，总结了很多资料，好累(-.-)\n\n\n","source":"_posts/使用Hexo和GitHub-Pages搭建博客.md","raw":"---\ntitle: 使用Hexo和GitHub Pages搭建免费独立博客及域名配置\ndate: 2016-11-11 16:31:52\ntoc: true \ncategories:\n\t- hexo\ntags:\n\t- hexo\n\t- github\n\t- blog\n---\n\n\n摘要：这是一篇使用GitHub Pages和Hexo搭建免费独立博客的总结。\n\n我在这里写下长篇大论，只希望小白们能更快速入门。一天搭建出属于自己的个人独立博客，我将会通过 安装流程主线+优质文章 作为参考。从我个人接触到成功搭建博客，走了很多弯路，网上的资料更是琳琅满目无从下手，希望通过本教程给想搭建个人博客的人一个敢于尝试的机会。我会将这篇教程写仔细，会将我出现过的问题给予解决方法。大家有问题可以留言，我会尽量帮助大家解决。\n\n\n\n\n# 前言\n为什么选择GitHub Pages？\n> * 无需购置服务器，目前的blog挂载在Github Pages，免服务器费的同时还能做负载均衡;\n* github pages有300M免费空间，资料自己管理，保存可靠；\n* 学着用github，享受github的便利，上面有很多大牛，眼界会开阔很多；\n* 顺便看看github工作原理，最好的团队协作流程；\n* github是趋势；\n\n\n<!--more-->\n\n# 准备工作\n相信自己，敢于面对，过程并不是很难。\n\n## Nodejs环境包\n\n因为 Hexo 是基于 Node.js 的第三方模块，所以缺少 Node.js 不可。访问 [Node.js官网](http://nodejs.org/)下载适合自己系统的 Node.js 安装包。目前最新的版本为 ｖ6.5.0。\n\n（注：至于安装过程和环境变量配置请参考[菜鸟教程-Node.js安装配置](http://www.runoob.com/nodejs/nodejs-install-setup.html)）\n\n## Git工具包\n\n如果之后你需要安装一些 Hexo 的主题和插件，[Git](https://git-scm.com/downloads/) 是最好的下载方式。因为好多主题都被放在了 Github 上，你只需要敲几个字符就可以下载。\n\n（注：宁浩网之前介绍过Git的使用方法，安装过程及简单使用请见[这里](http://ninghao.net/blog/1379)）\n\n### Git与GitHub区别\n\n这里，我们要区分清楚git与github。\ngit是一个版本控制的工具，而github有点类似于远程仓库，用于存放用git管理的各种项目。\n\n### 与GitHub建立联系\n\ngit安装好以后执行以下步骤：\n> 1. 从程序目录打开 \"Git Bash\" ,或者直接用git shell，github自带的工具\n2. 键入命令：ssh-keygen -t rsa -C \"email@email.com\"\n  \"email@email.com\"是github注册账号邮箱地址\n3. 提醒你输入key的名称，你可以不用输入，直接3个回车，就OK了；\n4. 在C:\\Documents and Settings\\Administrator\\下产生两个文件：id_rsa和id_rsa.pub\n5. 用记事本打开id_rsa.pub文件，复制内容，在github的网站上找到ssh密钥管理页面，添加新公钥 。\n6. 在git bash中输入ssh -T git@github.com命令，出现Hi username! You've successfully authenticated表示成功。\n\n### 设置用户信息\n\n现在你已经可以通过 SSH 链接到 GitHub 了，还有一些个人信息需要完善的。\n\nGit 会根据用户的名字和邮箱来记录提交。GitHub 也是用这些信息来做权限的处理，输入下面的代码进行个人信息的设置，把名称和邮箱替换成你自己的，名字必须是你的真名，而不是GitHub的昵称。\n```\n$ git config --global user.name \"***\"//用户名\n$ git config --global user.email \"****@****.com\"//填写自己的邮箱\n```\n\n# 开始搭建\n\n因为最终博客是要部署到github上的，这里我首先讲解github建立仓库，然后讲解hexo安装。为了方便大家一次部署成功并且考虑到以后如果大家换电脑或者重装系统后还能够修改以前的博客，请按照我的解决方案进行，这里大家不懂也没事，照着来就行，我会在文章末尾优化部署与管理中详解。\n\n## 创建GitHub Pages 仓库\n\n在自己的GitHub账号下创建一个新的仓库，命名为username.github.io\n（username是你的账号名)。在这里，要知道，GitHub Pages有两种类型：User/Organization Pages 和 Project Pages，而我所使用的是User Pages。\n简单来说，User Pages 与 Project Pages的区别是：\n> * User Pages 是用来展示用户的，而 Project Pages 是用来展示项目的。\n* 用于存放 User Pages 的仓库必须使用username.github.io的命名规则，而 Project Pages 则没有特殊的要求。\n* User Pages 将使用仓库的 master 分支，而 Project Pages 将使用 gh-pages 分支。\n* User Pages 通过 http(s)://username.github.io 进行访问，而 Projects * Pages通过 http(s)://username.github.io/projectname 进行访问。\n\n** 这一步很关键 **\n创建两个分支：master 与 hexo。** 设置hexo为默认分支 **（因为我们只需要手动管理这个分支上的Hexo网站文件）\n\n到这为止，我们的github仓库已经建立好了，我们马上就能见到成果了，下面我们开始建站。\n## hexo介绍\nHexo 是一个轻量的静态博客框架。通过Hexo可以快速生成一个静态博客框架,仅需要几条命令就可以完成,相当方便。\n\n而架设Hexo的环境更简单了 不需要 lnmp/lamp/XAMPP 这些繁琐复杂的环境 仅仅需要一个简单的http服务器即可使用 或者使用互联网上免费的页面托管服务\n\n比如本人的这个博客 就是托管于 GitHub Pages服务上\n## hexo安装\n安装Hexo相当简单。在安装之前，必须检查电脑中是否已经安装下列应用程序：\n* [Node.js](http://nodejs.org/)\n* [Git](http://git-scm.com/)\n\n如果您的电脑中已经安装上述必备程序，那么恭喜您！接下来只需要使用 npm 即可完成 Hexo 的安装。打开git bash执行以下命令：\n```\n$ npm install -g hexo-cli\n```\n这样hexo就已经安装好了。\n\n## 使用hexo建站\n\n安装完后，在你喜欢的文件夹内（我的是根目录）（例如H：\\），点击鼠标右键选择Git bash，输入以下指令（填自己的地址）：\n``` \ngit clone git@github.com:username/username.github.io.git \n```\n\n该命令会把你的博客仓库同步下来，然后cd到你的仓库文件夹下面依次执行以下命令：\n> 1、$ hexo init\n\n该命令会在目标文件夹内建立网站所需要的所有文件。接下来是安装依赖包：\n> 2、$ npm install\n\n这样，我们就已经搭建起本地的Hexo博客了。可以先执行以下命令（在对应文件夹下），然后再浏览器输入localhost:4000查看。\n> 3、$ hexo generate\n> 4、$ hexo server\n\n这个博客只是本地的，别人是浏览不了的，之后需要部署到GitHub上。\n\n### 相关资料\n\n* [Hexo 官方文档](https://hexo.io/zh-cn/docs/)\n\n## 部署博客到GitHub上\n\n部署其实很简单，只要改一下配置文件，执行几条命令就行了，为了以后的方便，现在麻烦了一点，大家跟着做就行了，具体原因也在配置管理与优化里有讲到。\n\n### 配置站点文件\n\n我们继续使用上面的文件夹H:\\username.github.io（也可以新建一个文件夹重新生成），然后编辑该文件夹下的_config.yml（这是站点配置文件）\n默认生成的_config.yml：\n``` \n# Deployment \n## Docs: http://hexo.io/docs/deployment.html \ndeploy:   \n  type:\n```\n修改后的_config.yml：（也是填入自己的ssh地址）\n``` \ndeploy:\n  type: git\n  repository: git@github.com:username/username.github.io.git\n  branch: master\n```\n这里解释一下前面为什么建立两个分支master和hexo，为了管理方便，以后master分支用来发布网站（一会再说怎么发布），hexo分支用来存放Hexo网站文件。\n### 发布\n为了能够使Hexo部署到GitHub上，需要安装一个插件：（在项目目录下执行命令）\n``` \n$ npm install hexo-deployer-git --save \n```\n然后，执行下列指令即可完成部署：（以后发布也按照这三条命令执行）\n``` \n$ hexo clean #清空public文件夹下生成的静态文件和db.json文件\n$ hexo generate #重新生成静态文件和db.json\n$ hexo deploy #按照站点配置文件部署到github上\n```\n之后，可以通过在浏览器键入：username.github.io进行浏览，开心吧~\n\n### 提交Hexo网站文件到hexo分支\n\n由于上面执行了hexo init命令，所以要重新关联远端库\n首先在项目文件夹下执行以下命令：\n``` \n$ git init #初始化为一个git目录\n$ git remote add origin git@github.com:username/username.github.io.git #使用你自己的地址关联\n$ git pull #pull一下你的远端库\n```\n此时你应该在hexo分支下，如下：\n``` \n$ H:\\username.github.io (hexo) (hexo-site@0.0.0)\n```\n如果不是，执行以下命令切换到hexo分支：\n``` \n$ git checkout hexo \n```\n然后执行以下命令提交网站相关文件：\n```\n$ git add . #添加所有文件到暂存区\n$ git commit -m \"提交信息\"     #提交到本地仓库\n$ git push origin hexo  #把本地库push到远端库的hexo分支\n```\n提交后去github上查看是否成功，这是我的[github地址](https://github.com/username/username.github.io)，看看是否一样。\n## 更换主题\n\n我使用的是[next主题]()，大家喜欢也可以去我的[github](https://github.com/username/username.github.io)上fork一下，然后在这基础上修改，大家也可以找自己喜欢的主题来换。\n如果想要使用其他主题，可以使用git clone将别人的主题拷贝到H:\\username.github.io\\themes下，然后将_config.yml中的theme: landscape改为对应的主题名字。\n下面以切换next主题为例来讲一下具体如何操作，同样也是在项目文件夹下执行以下命令：\n```\n$ git clone https://github.com/iissnan/hexo-theme-next.git themes/next\n```\n然后在站点配置文件_config.yml中的theme: landscape改为theme: next，重新发布一下就完成了。\n### 相关资料\n* [next主题使用文档](http://theme-next.iissnan.com/)\n\n\n# 优化部署与管理\n## 概述\nHexo部署到GitHub上的文件，是.md（你的博文）转化之后的.html（静态网页）。因此，当你重装电脑或者想在不同电脑上修改博客时，就不可能了（除非你自己写html）。\n其实，Hexo生成的网站文件中有.gitignore文件，因此它的本意也是想我们将Hexo生成的网站文件存放到GitHub上进行管理的（而不是用U盘或者云备份啦。）这样，不仅解决了上述的问题，还可以通过git的版本控制追踪你的博文的修改过程，是极赞的。\n但是，如果每一个GitHub Pages都需要创建一个额外的仓库来存放Hexo网站文件，我感觉很麻烦（10个项目需要20个仓库）。\n所以，我利用了分支！！！\n简单地说，每个想建立GitHub Pages的仓库，起码有两个分支，一个用来存放Hexo网站的文件，一个用来发布网站。\n下面以我的博客作为例子详细地讲述。\n### 我的博客搭建流程\n> 1、创建仓库，username.github.io；\n2、创建两个分支：master 与 hexo；\n3、设置hexo为默认分支（因为我们只需要手动管理这个分支上的Hexo网站文件）；\n4、使用git clone git@github.com:username/username.github.io.git拷贝仓库；\n5、在本地username.github.io文件夹下通过Git bash依次执行npm install hexo-cli、hexo init、npm install 和 npm install hexo-deployer-git（此时当前分支应显示为hexo）;\n6、修改_config.yml中的deploy参数，分支应为master；\n7、使用git init 、\ngit remote add origin git@github.com:username/username.github.io.git以及git pull命令重新关联远端库。\n8、使用git checkout hexo命令切换到hexo分支然后依次执行git add .、git commit -m “…”、git push origin hexo提交网站相关的文件；\n9、执行hexo g、 hexo d生成网站并部署到GitHub上。\n\n### shell脚本自动化\n开启 Hexo 的本地服务或者提交到github pages这些都是一些终端里的 Hexo 命令，所以笔者写了一些 shell 脚本，来简化这些操作。所以基本就是用 hey 可视化写文章，写好了之后，然后点击 一键部署 的 shell 脚本，然后就自动发布了（当然这也纯属鸡助，看个人。）。由于 shell 脚本比较简单，在此插入一个一键部署的shell脚本代码。\n```\n#!/bin/sh\ncd /your/path \nhexo clean\nhexo g\nhexo d\ngit add .\ngit commit -m \"modified\"\ngit push origin hexo\n```\n这样一来，在GitHub上的username.github.io仓库就有两个分支，一个hexo分支用来存放网站的原始文件，一个master分支用来存放生成的静态网页。完美！\n## 我的博客管理流程\n### 日常修改\n在本地对博客进行修改（添加新博文、修改样式等等）后，通过下面的流程进行管理：\n依次执行git add .、git commit -m “…”、git push origin hexo指令将改动推送到GitHub（此时当前分支应为hexo）；\n然后才执行hexo generate -d发布网站到master分支上。\n。\n### 本地资料丢失\n当重装电脑之后，或者想在其他电脑上修改博客，可以使用下列步骤：\n> 1、使用git clone git@github.com:username/username.github.io.git拷贝仓库（默认分支为hexo）；\n2、在本地新拷贝的username.github.io文件夹下通过Git bash依次执行下列指令：npm install hexo-cli、npm install、npm install hexo-deployer-git（记得，不需要hexo init这条指令）。\n\n# 购买域名及配置\n## 综述\n因为Hexo个人博客是托管在github之上，每次访问都要使用githubname.github.io这么一个长串的域名来访问，会显得非常繁琐。这个时候我们可以购买一个域名，设置DNS跳转，以达到通过域名即可访问我们的个人博客。通过查阅文档发现，github pages是支持域名绑定的。\n## 购买域名\n国内国外有很多的域名供应商，选择一个好的机构购买域名，会为自己的站点配置节约很多时间，也不会因为域名的出错，导致影响百度对我们个人博客的收录。近几年来，国内做的比较好的域名供应商有阿里的万网。我就是在阿里的[万网](https://wanwang.aliyun.com/)购买的域名。通过查找，找到自己喜欢的域名，后来为了解决成本，我选了.top结尾的域名，一年只需要4块钱，很便宜。\n## 域名配置\n~~### DNS地址解析\n修改域名的 DNS 地址为 f1g1ns1.dnspod.net 和 f1g1ns2.dnspod.net~~ \n### 域名解析\n~~登录进入万网的域名控制台，点击\"域名和网站\"中的\"云DNS\"，点击对应域名的\"解析\"。\n点击添加解析，记录类型选A或CNAME，A记录的记录值就是ip地址，github(官方文档)提供了两个IP地址，192.30.252.153和192.30.252.154，这两个IP地址为github的服务器地址，两个都要填上，解析记录设置两个www和@，线路就默认就行了（或ping自己的xx.github.io），CNAME记录值填你的github博客网址。如我的是sidney001.github.io。\n这些全部设置完成后，此时你并不能要申请的域名访问你的博客。接着你需要做的是在hexo根目录的source文件夹里创建CNAME文件，不带任何后缀，里面添加你的域名信息，如：sidney001.top。实践证明用www.sidney001.top和sidney001.top访问都是可以的。重新清理hexo,并发布即可用新的域名访问。~~\n\n在阿里云管理控制台中,选择中刚刚购买的域名,点击解析按钮\n这时会提醒你选择解析到阿里云主机,或者其他主机,这时需要将你在GitHub上创建的GitHub Pages的域名 xxx.github.io进行查询,得到一个IP地址。\n\n从ping指令得到一个IP地址 151.101.100.133, 将这个IP地址记录下来\n进入万网【域名控制台】》【域名解析】标签,选择【解析设置】,\n点击【添加设置】,添加一个记录类型为A,主机记录为www,解析线路默认,记录值为151.101.100.133的记录\n点击【添加设置】,再添加一个记录类型为A,主机记录为@,解析线路默认,记录值为151.101.100.133的记录。\n### Github 解析\n在GitHub的xxx.github.io项目,进入【Settings】标签页,在【Custom domain】功能中,将刚刚申请的域名写进去。\n\nGitHub设置完成,等几分钟,在浏览器输入刚刚购买的域名,就可以看到刚刚GitHub上的网站了!\n\n\n# 结尾\n在网上看了很多资料，总结了很多资料，好累(-.-)\n\n\n","slug":"使用Hexo和GitHub-Pages搭建博客","published":1,"updated":"2017-04-08T13:45:51.592Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj23iflza000bgolal0mes7dt","content":"<p>摘要：这是一篇使用GitHub Pages和Hexo搭建免费独立博客的总结。</p>\n<p>我在这里写下长篇大论，只希望小白们能更快速入门。一天搭建出属于自己的个人独立博客，我将会通过 安装流程主线+优质文章 作为参考。从我个人接触到成功搭建博客，走了很多弯路，网上的资料更是琳琅满目无从下手，希望通过本教程给想搭建个人博客的人一个敢于尝试的机会。我会将这篇教程写仔细，会将我出现过的问题给予解决方法。大家有问题可以留言，我会尽量帮助大家解决。</p>\n<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>为什么选择GitHub Pages？</p>\n<blockquote>\n<ul>\n<li>无需购置服务器，目前的blog挂载在Github Pages，免服务器费的同时还能做负载均衡;</li>\n<li>github pages有300M免费空间，资料自己管理，保存可靠；</li>\n<li>学着用github，享受github的便利，上面有很多大牛，眼界会开阔很多；</li>\n<li>顺便看看github工作原理，最好的团队协作流程；</li>\n<li>github是趋势；</li>\n</ul>\n</blockquote>\n<a id=\"more\"></a>\n<h1 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h1><p>相信自己，敢于面对，过程并不是很难。</p>\n<h2 id=\"Nodejs环境包\"><a href=\"#Nodejs环境包\" class=\"headerlink\" title=\"Nodejs环境包\"></a>Nodejs环境包</h2><p>因为 Hexo 是基于 Node.js 的第三方模块，所以缺少 Node.js 不可。访问 <a href=\"http://nodejs.org/\" target=\"_blank\" rel=\"external\">Node.js官网</a>下载适合自己系统的 Node.js 安装包。目前最新的版本为 ｖ6.5.0。</p>\n<p>（注：至于安装过程和环境变量配置请参考<a href=\"http://www.runoob.com/nodejs/nodejs-install-setup.html\" target=\"_blank\" rel=\"external\">菜鸟教程-Node.js安装配置</a>）</p>\n<h2 id=\"Git工具包\"><a href=\"#Git工具包\" class=\"headerlink\" title=\"Git工具包\"></a>Git工具包</h2><p>如果之后你需要安装一些 Hexo 的主题和插件，<a href=\"https://git-scm.com/downloads/\" target=\"_blank\" rel=\"external\">Git</a> 是最好的下载方式。因为好多主题都被放在了 Github 上，你只需要敲几个字符就可以下载。</p>\n<p>（注：宁浩网之前介绍过Git的使用方法，安装过程及简单使用请见<a href=\"http://ninghao.net/blog/1379\" target=\"_blank\" rel=\"external\">这里</a>）</p>\n<h3 id=\"Git与GitHub区别\"><a href=\"#Git与GitHub区别\" class=\"headerlink\" title=\"Git与GitHub区别\"></a>Git与GitHub区别</h3><p>这里，我们要区分清楚git与github。<br>git是一个版本控制的工具，而github有点类似于远程仓库，用于存放用git管理的各种项目。</p>\n<h3 id=\"与GitHub建立联系\"><a href=\"#与GitHub建立联系\" class=\"headerlink\" title=\"与GitHub建立联系\"></a>与GitHub建立联系</h3><p>git安装好以后执行以下步骤：</p>\n<blockquote>\n<ol>\n<li>从程序目录打开 “Git Bash” ,或者直接用git shell，github自带的工具</li>\n<li>键入命令：ssh-keygen -t rsa -C “email@email.com”<br>“email@email.com”是github注册账号邮箱地址</li>\n<li>提醒你输入key的名称，你可以不用输入，直接3个回车，就OK了；</li>\n<li>在C:\\Documents and Settings\\Administrator\\下产生两个文件：id_rsa和id_rsa.pub</li>\n<li>用记事本打开id_rsa.pub文件，复制内容，在github的网站上找到ssh密钥管理页面，添加新公钥 。</li>\n<li>在git bash中输入ssh -T git@github.com命令，出现Hi username! You’ve successfully authenticated表示成功。</li>\n</ol>\n</blockquote>\n<h3 id=\"设置用户信息\"><a href=\"#设置用户信息\" class=\"headerlink\" title=\"设置用户信息\"></a>设置用户信息</h3><p>现在你已经可以通过 SSH 链接到 GitHub 了，还有一些个人信息需要完善的。</p>\n<p>Git 会根据用户的名字和邮箱来记录提交。GitHub 也是用这些信息来做权限的处理，输入下面的代码进行个人信息的设置，把名称和邮箱替换成你自己的，名字必须是你的真名，而不是GitHub的昵称。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git config --global user.name &quot;***&quot;//用户名</div><div class=\"line\">$ git config --global user.email &quot;****@****.com&quot;//填写自己的邮箱</div></pre></td></tr></table></figure></p>\n<h1 id=\"开始搭建\"><a href=\"#开始搭建\" class=\"headerlink\" title=\"开始搭建\"></a>开始搭建</h1><p>因为最终博客是要部署到github上的，这里我首先讲解github建立仓库，然后讲解hexo安装。为了方便大家一次部署成功并且考虑到以后如果大家换电脑或者重装系统后还能够修改以前的博客，请按照我的解决方案进行，这里大家不懂也没事，照着来就行，我会在文章末尾优化部署与管理中详解。</p>\n<h2 id=\"创建GitHub-Pages-仓库\"><a href=\"#创建GitHub-Pages-仓库\" class=\"headerlink\" title=\"创建GitHub Pages 仓库\"></a>创建GitHub Pages 仓库</h2><p>在自己的GitHub账号下创建一个新的仓库，命名为username.github.io<br>（username是你的账号名)。在这里，要知道，GitHub Pages有两种类型：User/Organization Pages 和 Project Pages，而我所使用的是User Pages。<br>简单来说，User Pages 与 Project Pages的区别是：</p>\n<blockquote>\n<ul>\n<li>User Pages 是用来展示用户的，而 Project Pages 是用来展示项目的。</li>\n<li>用于存放 User Pages 的仓库必须使用username.github.io的命名规则，而 Project Pages 则没有特殊的要求。</li>\n<li>User Pages 将使用仓库的 master 分支，而 Project Pages 将使用 gh-pages 分支。</li>\n<li>User Pages 通过 http(s)://username.github.io 进行访问，而 Projects * Pages通过 http(s)://username.github.io/projectname 进行访问。</li>\n</ul>\n</blockquote>\n<p><strong> 这一步很关键 </strong><br>创建两个分支：master 与 hexo。<strong> 设置hexo为默认分支 </strong>（因为我们只需要手动管理这个分支上的Hexo网站文件）</p>\n<p>到这为止，我们的github仓库已经建立好了，我们马上就能见到成果了，下面我们开始建站。</p>\n<h2 id=\"hexo介绍\"><a href=\"#hexo介绍\" class=\"headerlink\" title=\"hexo介绍\"></a>hexo介绍</h2><p>Hexo 是一个轻量的静态博客框架。通过Hexo可以快速生成一个静态博客框架,仅需要几条命令就可以完成,相当方便。</p>\n<p>而架设Hexo的环境更简单了 不需要 lnmp/lamp/XAMPP 这些繁琐复杂的环境 仅仅需要一个简单的http服务器即可使用 或者使用互联网上免费的页面托管服务</p>\n<p>比如本人的这个博客 就是托管于 GitHub Pages服务上</p>\n<h2 id=\"hexo安装\"><a href=\"#hexo安装\" class=\"headerlink\" title=\"hexo安装\"></a>hexo安装</h2><p>安装Hexo相当简单。在安装之前，必须检查电脑中是否已经安装下列应用程序：</p>\n<ul>\n<li><a href=\"http://nodejs.org/\" target=\"_blank\" rel=\"external\">Node.js</a></li>\n<li><a href=\"http://git-scm.com/\" target=\"_blank\" rel=\"external\">Git</a></li>\n</ul>\n<p>如果您的电脑中已经安装上述必备程序，那么恭喜您！接下来只需要使用 npm 即可完成 Hexo 的安装。打开git bash执行以下命令：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ npm install -g hexo-cli</div></pre></td></tr></table></figure></p>\n<p>这样hexo就已经安装好了。</p>\n<h2 id=\"使用hexo建站\"><a href=\"#使用hexo建站\" class=\"headerlink\" title=\"使用hexo建站\"></a>使用hexo建站</h2><p>安装完后，在你喜欢的文件夹内（我的是根目录）（例如H：\\），点击鼠标右键选择Git bash，输入以下指令（填自己的地址）：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git clone git@github.com:username/username.github.io.git</div></pre></td></tr></table></figure></p>\n<p>该命令会把你的博客仓库同步下来，然后cd到你的仓库文件夹下面依次执行以下命令：</p>\n<blockquote>\n<p>1、$ hexo init</p>\n</blockquote>\n<p>该命令会在目标文件夹内建立网站所需要的所有文件。接下来是安装依赖包：</p>\n<blockquote>\n<p>2、$ npm install</p>\n</blockquote>\n<p>这样，我们就已经搭建起本地的Hexo博客了。可以先执行以下命令（在对应文件夹下），然后再浏览器输入localhost:4000查看。</p>\n<blockquote>\n<p>3、$ hexo generate<br>4、$ hexo server</p>\n</blockquote>\n<p>这个博客只是本地的，别人是浏览不了的，之后需要部署到GitHub上。</p>\n<h3 id=\"相关资料\"><a href=\"#相关资料\" class=\"headerlink\" title=\"相关资料\"></a>相关资料</h3><ul>\n<li><a href=\"https://hexo.io/zh-cn/docs/\" target=\"_blank\" rel=\"external\">Hexo 官方文档</a></li>\n</ul>\n<h2 id=\"部署博客到GitHub上\"><a href=\"#部署博客到GitHub上\" class=\"headerlink\" title=\"部署博客到GitHub上\"></a>部署博客到GitHub上</h2><p>部署其实很简单，只要改一下配置文件，执行几条命令就行了，为了以后的方便，现在麻烦了一点，大家跟着做就行了，具体原因也在配置管理与优化里有讲到。</p>\n<h3 id=\"配置站点文件\"><a href=\"#配置站点文件\" class=\"headerlink\" title=\"配置站点文件\"></a>配置站点文件</h3><p>我们继续使用上面的文件夹H:\\username.github.io（也可以新建一个文件夹重新生成），然后编辑该文件夹下的_config.yml（这是站点配置文件）<br>默认生成的_config.yml：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"># Deployment </div><div class=\"line\">## Docs: http://hexo.io/docs/deployment.html </div><div class=\"line\">deploy:   </div><div class=\"line\">  type:</div></pre></td></tr></table></figure></p>\n<p>修改后的_config.yml：（也是填入自己的ssh地址）<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">deploy:</div><div class=\"line\">  type: git</div><div class=\"line\">  repository: git@github.com:username/username.github.io.git</div><div class=\"line\">  branch: master</div></pre></td></tr></table></figure></p>\n<p>这里解释一下前面为什么建立两个分支master和hexo，为了管理方便，以后master分支用来发布网站（一会再说怎么发布），hexo分支用来存放Hexo网站文件。</p>\n<h3 id=\"发布\"><a href=\"#发布\" class=\"headerlink\" title=\"发布\"></a>发布</h3><p>为了能够使Hexo部署到GitHub上，需要安装一个插件：（在项目目录下执行命令）<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ npm install hexo-deployer-git --save</div></pre></td></tr></table></figure></p>\n<p>然后，执行下列指令即可完成部署：（以后发布也按照这三条命令执行）<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo clean #清空public文件夹下生成的静态文件和db.json文件</div><div class=\"line\">$ hexo generate #重新生成静态文件和db.json</div><div class=\"line\">$ hexo deploy #按照站点配置文件部署到github上</div></pre></td></tr></table></figure></p>\n<p>之后，可以通过在浏览器键入：username.github.io进行浏览，开心吧~</p>\n<h3 id=\"提交Hexo网站文件到hexo分支\"><a href=\"#提交Hexo网站文件到hexo分支\" class=\"headerlink\" title=\"提交Hexo网站文件到hexo分支\"></a>提交Hexo网站文件到hexo分支</h3><p>由于上面执行了hexo init命令，所以要重新关联远端库<br>首先在项目文件夹下执行以下命令：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git init #初始化为一个git目录</div><div class=\"line\">$ git remote add origin git@github.com:username/username.github.io.git #使用你自己的地址关联</div><div class=\"line\">$ git pull #pull一下你的远端库</div></pre></td></tr></table></figure></p>\n<p>此时你应该在hexo分支下，如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ H:\\username.github.io (hexo) (hexo-site@0.0.0)</div></pre></td></tr></table></figure></p>\n<p>如果不是，执行以下命令切换到hexo分支：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git checkout hexo</div></pre></td></tr></table></figure></p>\n<p>然后执行以下命令提交网站相关文件：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git add . #添加所有文件到暂存区</div><div class=\"line\">$ git commit -m &quot;提交信息&quot;     #提交到本地仓库</div><div class=\"line\">$ git push origin hexo  #把本地库push到远端库的hexo分支</div></pre></td></tr></table></figure></p>\n<p>提交后去github上查看是否成功，这是我的<a href=\"https://github.com/username/username.github.io\" target=\"_blank\" rel=\"external\">github地址</a>，看看是否一样。</p>\n<h2 id=\"更换主题\"><a href=\"#更换主题\" class=\"headerlink\" title=\"更换主题\"></a>更换主题</h2><p>我使用的是<a href=\"\">next主题</a>，大家喜欢也可以去我的<a href=\"https://github.com/username/username.github.io\" target=\"_blank\" rel=\"external\">github</a>上fork一下，然后在这基础上修改，大家也可以找自己喜欢的主题来换。<br>如果想要使用其他主题，可以使用git clone将别人的主题拷贝到H:\\username.github.io\\themes下，然后将_config.yml中的theme: landscape改为对应的主题名字。<br>下面以切换next主题为例来讲一下具体如何操作，同样也是在项目文件夹下执行以下命令：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git clone https://github.com/iissnan/hexo-theme-next.git themes/next</div></pre></td></tr></table></figure></p>\n<p>然后在站点配置文件_config.yml中的theme: landscape改为theme: next，重新发布一下就完成了。</p>\n<h3 id=\"相关资料-1\"><a href=\"#相关资料-1\" class=\"headerlink\" title=\"相关资料\"></a>相关资料</h3><ul>\n<li><a href=\"http://theme-next.iissnan.com/\" target=\"_blank\" rel=\"external\">next主题使用文档</a></li>\n</ul>\n<h1 id=\"优化部署与管理\"><a href=\"#优化部署与管理\" class=\"headerlink\" title=\"优化部署与管理\"></a>优化部署与管理</h1><h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>Hexo部署到GitHub上的文件，是.md（你的博文）转化之后的.html（静态网页）。因此，当你重装电脑或者想在不同电脑上修改博客时，就不可能了（除非你自己写html）。<br>其实，Hexo生成的网站文件中有.gitignore文件，因此它的本意也是想我们将Hexo生成的网站文件存放到GitHub上进行管理的（而不是用U盘或者云备份啦。）这样，不仅解决了上述的问题，还可以通过git的版本控制追踪你的博文的修改过程，是极赞的。<br>但是，如果每一个GitHub Pages都需要创建一个额外的仓库来存放Hexo网站文件，我感觉很麻烦（10个项目需要20个仓库）。<br>所以，我利用了分支！！！<br>简单地说，每个想建立GitHub Pages的仓库，起码有两个分支，一个用来存放Hexo网站的文件，一个用来发布网站。<br>下面以我的博客作为例子详细地讲述。</p>\n<h3 id=\"我的博客搭建流程\"><a href=\"#我的博客搭建流程\" class=\"headerlink\" title=\"我的博客搭建流程\"></a>我的博客搭建流程</h3><blockquote>\n<p>1、创建仓库，username.github.io；<br>2、创建两个分支：master 与 hexo；<br>3、设置hexo为默认分支（因为我们只需要手动管理这个分支上的Hexo网站文件）；<br>4、使用git clone git@github.com:username/username.github.io.git拷贝仓库；<br>5、在本地username.github.io文件夹下通过Git bash依次执行npm install hexo-cli、hexo init、npm install 和 npm install hexo-deployer-git（此时当前分支应显示为hexo）;<br>6、修改_config.yml中的deploy参数，分支应为master；<br>7、使用git init 、<br>git remote add origin git@github.com:username/username.github.io.git以及git pull命令重新关联远端库。<br>8、使用git checkout hexo命令切换到hexo分支然后依次执行git add .、git commit -m “…”、git push origin hexo提交网站相关的文件；<br>9、执行hexo g、 hexo d生成网站并部署到GitHub上。</p>\n</blockquote>\n<h3 id=\"shell脚本自动化\"><a href=\"#shell脚本自动化\" class=\"headerlink\" title=\"shell脚本自动化\"></a>shell脚本自动化</h3><p>开启 Hexo 的本地服务或者提交到github pages这些都是一些终端里的 Hexo 命令，所以笔者写了一些 shell 脚本，来简化这些操作。所以基本就是用 hey 可视化写文章，写好了之后，然后点击 一键部署 的 shell 脚本，然后就自动发布了（当然这也纯属鸡助，看个人。）。由于 shell 脚本比较简单，在此插入一个一键部署的shell脚本代码。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">#!/bin/sh</div><div class=\"line\">cd /your/path </div><div class=\"line\">hexo clean</div><div class=\"line\">hexo g</div><div class=\"line\">hexo d</div><div class=\"line\">git add .</div><div class=\"line\">git commit -m &quot;modified&quot;</div><div class=\"line\">git push origin hexo</div></pre></td></tr></table></figure></p>\n<p>这样一来，在GitHub上的username.github.io仓库就有两个分支，一个hexo分支用来存放网站的原始文件，一个master分支用来存放生成的静态网页。完美！</p>\n<h2 id=\"我的博客管理流程\"><a href=\"#我的博客管理流程\" class=\"headerlink\" title=\"我的博客管理流程\"></a>我的博客管理流程</h2><h3 id=\"日常修改\"><a href=\"#日常修改\" class=\"headerlink\" title=\"日常修改\"></a>日常修改</h3><p>在本地对博客进行修改（添加新博文、修改样式等等）后，通过下面的流程进行管理：<br>依次执行git add .、git commit -m “…”、git push origin hexo指令将改动推送到GitHub（此时当前分支应为hexo）；<br>然后才执行hexo generate -d发布网站到master分支上。<br>。</p>\n<h3 id=\"本地资料丢失\"><a href=\"#本地资料丢失\" class=\"headerlink\" title=\"本地资料丢失\"></a>本地资料丢失</h3><p>当重装电脑之后，或者想在其他电脑上修改博客，可以使用下列步骤：</p>\n<blockquote>\n<p>1、使用git clone git@github.com:username/username.github.io.git拷贝仓库（默认分支为hexo）；<br>2、在本地新拷贝的username.github.io文件夹下通过Git bash依次执行下列指令：npm install hexo-cli、npm install、npm install hexo-deployer-git（记得，不需要hexo init这条指令）。</p>\n</blockquote>\n<h1 id=\"购买域名及配置\"><a href=\"#购买域名及配置\" class=\"headerlink\" title=\"购买域名及配置\"></a>购买域名及配置</h1><h2 id=\"综述\"><a href=\"#综述\" class=\"headerlink\" title=\"综述\"></a>综述</h2><p>因为Hexo个人博客是托管在github之上，每次访问都要使用githubname.github.io这么一个长串的域名来访问，会显得非常繁琐。这个时候我们可以购买一个域名，设置DNS跳转，以达到通过域名即可访问我们的个人博客。通过查阅文档发现，github pages是支持域名绑定的。</p>\n<h2 id=\"购买域名\"><a href=\"#购买域名\" class=\"headerlink\" title=\"购买域名\"></a>购买域名</h2><p>国内国外有很多的域名供应商，选择一个好的机构购买域名，会为自己的站点配置节约很多时间，也不会因为域名的出错，导致影响百度对我们个人博客的收录。近几年来，国内做的比较好的域名供应商有阿里的万网。我就是在阿里的<a href=\"https://wanwang.aliyun.com/\" target=\"_blank\" rel=\"external\">万网</a>购买的域名。通过查找，找到自己喜欢的域名，后来为了解决成本，我选了.top结尾的域名，一年只需要4块钱，很便宜。</p>\n<h2 id=\"域名配置\"><a href=\"#域名配置\" class=\"headerlink\" title=\"域名配置\"></a>域名配置</h2><p><del>### DNS地址解析<br>修改域名的 DNS 地址为 f1g1ns1.dnspod.net 和 f1g1ns2.dnspod.net</del> </p>\n<h3 id=\"域名解析\"><a href=\"#域名解析\" class=\"headerlink\" title=\"域名解析\"></a>域名解析</h3><p><del>登录进入万网的域名控制台，点击”域名和网站”中的”云DNS”，点击对应域名的”解析”。<br>点击添加解析，记录类型选A或CNAME，A记录的记录值就是ip地址，github(官方文档)提供了两个IP地址，192.30.252.153和192.30.252.154，这两个IP地址为github的服务器地址，两个都要填上，解析记录设置两个www和@，线路就默认就行了（或ping自己的xx.github.io），CNAME记录值填你的github博客网址。如我的是sidney001.github.io。<br>这些全部设置完成后，此时你并不能要申请的域名访问你的博客。接着你需要做的是在hexo根目录的source文件夹里创建CNAME文件，不带任何后缀，里面添加你的域名信息，如：sidney001.top。实践证明用www.sidney001.top和sidney001.top访问都是可以的。重新清理hexo,并发布即可用新的域名访问。</del></p>\n<p>在阿里云管理控制台中,选择中刚刚购买的域名,点击解析按钮<br>这时会提醒你选择解析到阿里云主机,或者其他主机,这时需要将你在GitHub上创建的GitHub Pages的域名 xxx.github.io进行查询,得到一个IP地址。</p>\n<p>从ping指令得到一个IP地址 151.101.100.133, 将这个IP地址记录下来<br>进入万网【域名控制台】》【域名解析】标签,选择【解析设置】,<br>点击【添加设置】,添加一个记录类型为A,主机记录为www,解析线路默认,记录值为151.101.100.133的记录<br>点击【添加设置】,再添加一个记录类型为A,主机记录为@,解析线路默认,记录值为151.101.100.133的记录。</p>\n<h3 id=\"Github-解析\"><a href=\"#Github-解析\" class=\"headerlink\" title=\"Github 解析\"></a>Github 解析</h3><p>在GitHub的xxx.github.io项目,进入【Settings】标签页,在【Custom domain】功能中,将刚刚申请的域名写进去。</p>\n<p>GitHub设置完成,等几分钟,在浏览器输入刚刚购买的域名,就可以看到刚刚GitHub上的网站了!</p>\n<h1 id=\"结尾\"><a href=\"#结尾\" class=\"headerlink\" title=\"结尾\"></a>结尾</h1><p>在网上看了很多资料，总结了很多资料，好累(-.-)</p>\n","excerpt":"<p>摘要：这是一篇使用GitHub Pages和Hexo搭建免费独立博客的总结。</p>\n<p>我在这里写下长篇大论，只希望小白们能更快速入门。一天搭建出属于自己的个人独立博客，我将会通过 安装流程主线+优质文章 作为参考。从我个人接触到成功搭建博客，走了很多弯路，网上的资料更是琳琅满目无从下手，希望通过本教程给想搭建个人博客的人一个敢于尝试的机会。我会将这篇教程写仔细，会将我出现过的问题给予解决方法。大家有问题可以留言，我会尽量帮助大家解决。</p>\n<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>为什么选择GitHub Pages？</p>\n<blockquote>\n<ul>\n<li>无需购置服务器，目前的blog挂载在Github Pages，免服务器费的同时还能做负载均衡;</li>\n<li>github pages有300M免费空间，资料自己管理，保存可靠；</li>\n<li>学着用github，享受github的便利，上面有很多大牛，眼界会开阔很多；</li>\n<li>顺便看看github工作原理，最好的团队协作流程；</li>\n<li>github是趋势；</li>\n</ul>\n</blockquote>","more":"<h1 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h1><p>相信自己，敢于面对，过程并不是很难。</p>\n<h2 id=\"Nodejs环境包\"><a href=\"#Nodejs环境包\" class=\"headerlink\" title=\"Nodejs环境包\"></a>Nodejs环境包</h2><p>因为 Hexo 是基于 Node.js 的第三方模块，所以缺少 Node.js 不可。访问 <a href=\"http://nodejs.org/\">Node.js官网</a>下载适合自己系统的 Node.js 安装包。目前最新的版本为 ｖ6.5.0。</p>\n<p>（注：至于安装过程和环境变量配置请参考<a href=\"http://www.runoob.com/nodejs/nodejs-install-setup.html\">菜鸟教程-Node.js安装配置</a>）</p>\n<h2 id=\"Git工具包\"><a href=\"#Git工具包\" class=\"headerlink\" title=\"Git工具包\"></a>Git工具包</h2><p>如果之后你需要安装一些 Hexo 的主题和插件，<a href=\"https://git-scm.com/downloads/\">Git</a> 是最好的下载方式。因为好多主题都被放在了 Github 上，你只需要敲几个字符就可以下载。</p>\n<p>（注：宁浩网之前介绍过Git的使用方法，安装过程及简单使用请见<a href=\"http://ninghao.net/blog/1379\">这里</a>）</p>\n<h3 id=\"Git与GitHub区别\"><a href=\"#Git与GitHub区别\" class=\"headerlink\" title=\"Git与GitHub区别\"></a>Git与GitHub区别</h3><p>这里，我们要区分清楚git与github。<br>git是一个版本控制的工具，而github有点类似于远程仓库，用于存放用git管理的各种项目。</p>\n<h3 id=\"与GitHub建立联系\"><a href=\"#与GitHub建立联系\" class=\"headerlink\" title=\"与GitHub建立联系\"></a>与GitHub建立联系</h3><p>git安装好以后执行以下步骤：</p>\n<blockquote>\n<ol>\n<li>从程序目录打开 “Git Bash” ,或者直接用git shell，github自带的工具</li>\n<li>键入命令：ssh-keygen -t rsa -C “email@email.com”<br>“email@email.com”是github注册账号邮箱地址</li>\n<li>提醒你输入key的名称，你可以不用输入，直接3个回车，就OK了；</li>\n<li>在C:\\Documents and Settings\\Administrator\\下产生两个文件：id_rsa和id_rsa.pub</li>\n<li>用记事本打开id_rsa.pub文件，复制内容，在github的网站上找到ssh密钥管理页面，添加新公钥 。</li>\n<li>在git bash中输入ssh -T git@github.com命令，出现Hi username! You’ve successfully authenticated表示成功。</li>\n</ol>\n</blockquote>\n<h3 id=\"设置用户信息\"><a href=\"#设置用户信息\" class=\"headerlink\" title=\"设置用户信息\"></a>设置用户信息</h3><p>现在你已经可以通过 SSH 链接到 GitHub 了，还有一些个人信息需要完善的。</p>\n<p>Git 会根据用户的名字和邮箱来记录提交。GitHub 也是用这些信息来做权限的处理，输入下面的代码进行个人信息的设置，把名称和邮箱替换成你自己的，名字必须是你的真名，而不是GitHub的昵称。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git config --global user.name &quot;***&quot;//用户名</div><div class=\"line\">$ git config --global user.email &quot;****@****.com&quot;//填写自己的邮箱</div></pre></td></tr></table></figure></p>\n<h1 id=\"开始搭建\"><a href=\"#开始搭建\" class=\"headerlink\" title=\"开始搭建\"></a>开始搭建</h1><p>因为最终博客是要部署到github上的，这里我首先讲解github建立仓库，然后讲解hexo安装。为了方便大家一次部署成功并且考虑到以后如果大家换电脑或者重装系统后还能够修改以前的博客，请按照我的解决方案进行，这里大家不懂也没事，照着来就行，我会在文章末尾优化部署与管理中详解。</p>\n<h2 id=\"创建GitHub-Pages-仓库\"><a href=\"#创建GitHub-Pages-仓库\" class=\"headerlink\" title=\"创建GitHub Pages 仓库\"></a>创建GitHub Pages 仓库</h2><p>在自己的GitHub账号下创建一个新的仓库，命名为username.github.io<br>（username是你的账号名)。在这里，要知道，GitHub Pages有两种类型：User/Organization Pages 和 Project Pages，而我所使用的是User Pages。<br>简单来说，User Pages 与 Project Pages的区别是：</p>\n<blockquote>\n<ul>\n<li>User Pages 是用来展示用户的，而 Project Pages 是用来展示项目的。</li>\n<li>用于存放 User Pages 的仓库必须使用username.github.io的命名规则，而 Project Pages 则没有特殊的要求。</li>\n<li>User Pages 将使用仓库的 master 分支，而 Project Pages 将使用 gh-pages 分支。</li>\n<li>User Pages 通过 http(s)://username.github.io 进行访问，而 Projects * Pages通过 http(s)://username.github.io/projectname 进行访问。</li>\n</ul>\n</blockquote>\n<p><strong> 这一步很关键 </strong><br>创建两个分支：master 与 hexo。<strong> 设置hexo为默认分支 </strong>（因为我们只需要手动管理这个分支上的Hexo网站文件）</p>\n<p>到这为止，我们的github仓库已经建立好了，我们马上就能见到成果了，下面我们开始建站。</p>\n<h2 id=\"hexo介绍\"><a href=\"#hexo介绍\" class=\"headerlink\" title=\"hexo介绍\"></a>hexo介绍</h2><p>Hexo 是一个轻量的静态博客框架。通过Hexo可以快速生成一个静态博客框架,仅需要几条命令就可以完成,相当方便。</p>\n<p>而架设Hexo的环境更简单了 不需要 lnmp/lamp/XAMPP 这些繁琐复杂的环境 仅仅需要一个简单的http服务器即可使用 或者使用互联网上免费的页面托管服务</p>\n<p>比如本人的这个博客 就是托管于 GitHub Pages服务上</p>\n<h2 id=\"hexo安装\"><a href=\"#hexo安装\" class=\"headerlink\" title=\"hexo安装\"></a>hexo安装</h2><p>安装Hexo相当简单。在安装之前，必须检查电脑中是否已经安装下列应用程序：</p>\n<ul>\n<li><a href=\"http://nodejs.org/\">Node.js</a></li>\n<li><a href=\"http://git-scm.com/\">Git</a></li>\n</ul>\n<p>如果您的电脑中已经安装上述必备程序，那么恭喜您！接下来只需要使用 npm 即可完成 Hexo 的安装。打开git bash执行以下命令：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ npm install -g hexo-cli</div></pre></td></tr></table></figure></p>\n<p>这样hexo就已经安装好了。</p>\n<h2 id=\"使用hexo建站\"><a href=\"#使用hexo建站\" class=\"headerlink\" title=\"使用hexo建站\"></a>使用hexo建站</h2><p>安装完后，在你喜欢的文件夹内（我的是根目录）（例如H：\\），点击鼠标右键选择Git bash，输入以下指令（填自己的地址）：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git clone git@github.com:username/username.github.io.git</div></pre></td></tr></table></figure></p>\n<p>该命令会把你的博客仓库同步下来，然后cd到你的仓库文件夹下面依次执行以下命令：</p>\n<blockquote>\n<p>1、$ hexo init</p>\n</blockquote>\n<p>该命令会在目标文件夹内建立网站所需要的所有文件。接下来是安装依赖包：</p>\n<blockquote>\n<p>2、$ npm install</p>\n</blockquote>\n<p>这样，我们就已经搭建起本地的Hexo博客了。可以先执行以下命令（在对应文件夹下），然后再浏览器输入localhost:4000查看。</p>\n<blockquote>\n<p>3、$ hexo generate<br>4、$ hexo server</p>\n</blockquote>\n<p>这个博客只是本地的，别人是浏览不了的，之后需要部署到GitHub上。</p>\n<h3 id=\"相关资料\"><a href=\"#相关资料\" class=\"headerlink\" title=\"相关资料\"></a>相关资料</h3><ul>\n<li><a href=\"https://hexo.io/zh-cn/docs/\">Hexo 官方文档</a></li>\n</ul>\n<h2 id=\"部署博客到GitHub上\"><a href=\"#部署博客到GitHub上\" class=\"headerlink\" title=\"部署博客到GitHub上\"></a>部署博客到GitHub上</h2><p>部署其实很简单，只要改一下配置文件，执行几条命令就行了，为了以后的方便，现在麻烦了一点，大家跟着做就行了，具体原因也在配置管理与优化里有讲到。</p>\n<h3 id=\"配置站点文件\"><a href=\"#配置站点文件\" class=\"headerlink\" title=\"配置站点文件\"></a>配置站点文件</h3><p>我们继续使用上面的文件夹H:\\username.github.io（也可以新建一个文件夹重新生成），然后编辑该文件夹下的_config.yml（这是站点配置文件）<br>默认生成的_config.yml：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"># Deployment </div><div class=\"line\">## Docs: http://hexo.io/docs/deployment.html </div><div class=\"line\">deploy:   </div><div class=\"line\">  type:</div></pre></td></tr></table></figure></p>\n<p>修改后的_config.yml：（也是填入自己的ssh地址）<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">deploy:</div><div class=\"line\">  type: git</div><div class=\"line\">  repository: git@github.com:username/username.github.io.git</div><div class=\"line\">  branch: master</div></pre></td></tr></table></figure></p>\n<p>这里解释一下前面为什么建立两个分支master和hexo，为了管理方便，以后master分支用来发布网站（一会再说怎么发布），hexo分支用来存放Hexo网站文件。</p>\n<h3 id=\"发布\"><a href=\"#发布\" class=\"headerlink\" title=\"发布\"></a>发布</h3><p>为了能够使Hexo部署到GitHub上，需要安装一个插件：（在项目目录下执行命令）<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ npm install hexo-deployer-git --save</div></pre></td></tr></table></figure></p>\n<p>然后，执行下列指令即可完成部署：（以后发布也按照这三条命令执行）<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo clean #清空public文件夹下生成的静态文件和db.json文件</div><div class=\"line\">$ hexo generate #重新生成静态文件和db.json</div><div class=\"line\">$ hexo deploy #按照站点配置文件部署到github上</div></pre></td></tr></table></figure></p>\n<p>之后，可以通过在浏览器键入：username.github.io进行浏览，开心吧~</p>\n<h3 id=\"提交Hexo网站文件到hexo分支\"><a href=\"#提交Hexo网站文件到hexo分支\" class=\"headerlink\" title=\"提交Hexo网站文件到hexo分支\"></a>提交Hexo网站文件到hexo分支</h3><p>由于上面执行了hexo init命令，所以要重新关联远端库<br>首先在项目文件夹下执行以下命令：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git init #初始化为一个git目录</div><div class=\"line\">$ git remote add origin git@github.com:username/username.github.io.git #使用你自己的地址关联</div><div class=\"line\">$ git pull #pull一下你的远端库</div></pre></td></tr></table></figure></p>\n<p>此时你应该在hexo分支下，如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ H:\\username.github.io (hexo) (hexo-site@0.0.0)</div></pre></td></tr></table></figure></p>\n<p>如果不是，执行以下命令切换到hexo分支：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git checkout hexo</div></pre></td></tr></table></figure></p>\n<p>然后执行以下命令提交网站相关文件：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git add . #添加所有文件到暂存区</div><div class=\"line\">$ git commit -m &quot;提交信息&quot;     #提交到本地仓库</div><div class=\"line\">$ git push origin hexo  #把本地库push到远端库的hexo分支</div></pre></td></tr></table></figure></p>\n<p>提交后去github上查看是否成功，这是我的<a href=\"https://github.com/username/username.github.io\">github地址</a>，看看是否一样。</p>\n<h2 id=\"更换主题\"><a href=\"#更换主题\" class=\"headerlink\" title=\"更换主题\"></a>更换主题</h2><p>我使用的是<a href=\"\">next主题</a>，大家喜欢也可以去我的<a href=\"https://github.com/username/username.github.io\">github</a>上fork一下，然后在这基础上修改，大家也可以找自己喜欢的主题来换。<br>如果想要使用其他主题，可以使用git clone将别人的主题拷贝到H:\\username.github.io\\themes下，然后将_config.yml中的theme: landscape改为对应的主题名字。<br>下面以切换next主题为例来讲一下具体如何操作，同样也是在项目文件夹下执行以下命令：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git clone https://github.com/iissnan/hexo-theme-next.git themes/next</div></pre></td></tr></table></figure></p>\n<p>然后在站点配置文件_config.yml中的theme: landscape改为theme: next，重新发布一下就完成了。</p>\n<h3 id=\"相关资料-1\"><a href=\"#相关资料-1\" class=\"headerlink\" title=\"相关资料\"></a>相关资料</h3><ul>\n<li><a href=\"http://theme-next.iissnan.com/\">next主题使用文档</a></li>\n</ul>\n<h1 id=\"优化部署与管理\"><a href=\"#优化部署与管理\" class=\"headerlink\" title=\"优化部署与管理\"></a>优化部署与管理</h1><h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>Hexo部署到GitHub上的文件，是.md（你的博文）转化之后的.html（静态网页）。因此，当你重装电脑或者想在不同电脑上修改博客时，就不可能了（除非你自己写html）。<br>其实，Hexo生成的网站文件中有.gitignore文件，因此它的本意也是想我们将Hexo生成的网站文件存放到GitHub上进行管理的（而不是用U盘或者云备份啦。）这样，不仅解决了上述的问题，还可以通过git的版本控制追踪你的博文的修改过程，是极赞的。<br>但是，如果每一个GitHub Pages都需要创建一个额外的仓库来存放Hexo网站文件，我感觉很麻烦（10个项目需要20个仓库）。<br>所以，我利用了分支！！！<br>简单地说，每个想建立GitHub Pages的仓库，起码有两个分支，一个用来存放Hexo网站的文件，一个用来发布网站。<br>下面以我的博客作为例子详细地讲述。</p>\n<h3 id=\"我的博客搭建流程\"><a href=\"#我的博客搭建流程\" class=\"headerlink\" title=\"我的博客搭建流程\"></a>我的博客搭建流程</h3><blockquote>\n<p>1、创建仓库，username.github.io；<br>2、创建两个分支：master 与 hexo；<br>3、设置hexo为默认分支（因为我们只需要手动管理这个分支上的Hexo网站文件）；<br>4、使用git clone git@github.com:username/username.github.io.git拷贝仓库；<br>5、在本地username.github.io文件夹下通过Git bash依次执行npm install hexo-cli、hexo init、npm install 和 npm install hexo-deployer-git（此时当前分支应显示为hexo）;<br>6、修改_config.yml中的deploy参数，分支应为master；<br>7、使用git init 、<br>git remote add origin git@github.com:username/username.github.io.git以及git pull命令重新关联远端库。<br>8、使用git checkout hexo命令切换到hexo分支然后依次执行git add .、git commit -m “…”、git push origin hexo提交网站相关的文件；<br>9、执行hexo g、 hexo d生成网站并部署到GitHub上。</p>\n</blockquote>\n<h3 id=\"shell脚本自动化\"><a href=\"#shell脚本自动化\" class=\"headerlink\" title=\"shell脚本自动化\"></a>shell脚本自动化</h3><p>开启 Hexo 的本地服务或者提交到github pages这些都是一些终端里的 Hexo 命令，所以笔者写了一些 shell 脚本，来简化这些操作。所以基本就是用 hey 可视化写文章，写好了之后，然后点击 一键部署 的 shell 脚本，然后就自动发布了（当然这也纯属鸡助，看个人。）。由于 shell 脚本比较简单，在此插入一个一键部署的shell脚本代码。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">#!/bin/sh</div><div class=\"line\">cd /your/path </div><div class=\"line\">hexo clean</div><div class=\"line\">hexo g</div><div class=\"line\">hexo d</div><div class=\"line\">git add .</div><div class=\"line\">git commit -m &quot;modified&quot;</div><div class=\"line\">git push origin hexo</div></pre></td></tr></table></figure></p>\n<p>这样一来，在GitHub上的username.github.io仓库就有两个分支，一个hexo分支用来存放网站的原始文件，一个master分支用来存放生成的静态网页。完美！</p>\n<h2 id=\"我的博客管理流程\"><a href=\"#我的博客管理流程\" class=\"headerlink\" title=\"我的博客管理流程\"></a>我的博客管理流程</h2><h3 id=\"日常修改\"><a href=\"#日常修改\" class=\"headerlink\" title=\"日常修改\"></a>日常修改</h3><p>在本地对博客进行修改（添加新博文、修改样式等等）后，通过下面的流程进行管理：<br>依次执行git add .、git commit -m “…”、git push origin hexo指令将改动推送到GitHub（此时当前分支应为hexo）；<br>然后才执行hexo generate -d发布网站到master分支上。<br>。</p>\n<h3 id=\"本地资料丢失\"><a href=\"#本地资料丢失\" class=\"headerlink\" title=\"本地资料丢失\"></a>本地资料丢失</h3><p>当重装电脑之后，或者想在其他电脑上修改博客，可以使用下列步骤：</p>\n<blockquote>\n<p>1、使用git clone git@github.com:username/username.github.io.git拷贝仓库（默认分支为hexo）；<br>2、在本地新拷贝的username.github.io文件夹下通过Git bash依次执行下列指令：npm install hexo-cli、npm install、npm install hexo-deployer-git（记得，不需要hexo init这条指令）。</p>\n</blockquote>\n<h1 id=\"购买域名及配置\"><a href=\"#购买域名及配置\" class=\"headerlink\" title=\"购买域名及配置\"></a>购买域名及配置</h1><h2 id=\"综述\"><a href=\"#综述\" class=\"headerlink\" title=\"综述\"></a>综述</h2><p>因为Hexo个人博客是托管在github之上，每次访问都要使用githubname.github.io这么一个长串的域名来访问，会显得非常繁琐。这个时候我们可以购买一个域名，设置DNS跳转，以达到通过域名即可访问我们的个人博客。通过查阅文档发现，github pages是支持域名绑定的。</p>\n<h2 id=\"购买域名\"><a href=\"#购买域名\" class=\"headerlink\" title=\"购买域名\"></a>购买域名</h2><p>国内国外有很多的域名供应商，选择一个好的机构购买域名，会为自己的站点配置节约很多时间，也不会因为域名的出错，导致影响百度对我们个人博客的收录。近几年来，国内做的比较好的域名供应商有阿里的万网。我就是在阿里的<a href=\"https://wanwang.aliyun.com/\">万网</a>购买的域名。通过查找，找到自己喜欢的域名，后来为了解决成本，我选了.top结尾的域名，一年只需要4块钱，很便宜。</p>\n<h2 id=\"域名配置\"><a href=\"#域名配置\" class=\"headerlink\" title=\"域名配置\"></a>域名配置</h2><p><del>### DNS地址解析<br>修改域名的 DNS 地址为 f1g1ns1.dnspod.net 和 f1g1ns2.dnspod.net</del> </p>\n<h3 id=\"域名解析\"><a href=\"#域名解析\" class=\"headerlink\" title=\"域名解析\"></a>域名解析</h3><p><del>登录进入万网的域名控制台，点击”域名和网站”中的”云DNS”，点击对应域名的”解析”。<br>点击添加解析，记录类型选A或CNAME，A记录的记录值就是ip地址，github(官方文档)提供了两个IP地址，192.30.252.153和192.30.252.154，这两个IP地址为github的服务器地址，两个都要填上，解析记录设置两个www和@，线路就默认就行了（或ping自己的xx.github.io），CNAME记录值填你的github博客网址。如我的是sidney001.github.io。<br>这些全部设置完成后，此时你并不能要申请的域名访问你的博客。接着你需要做的是在hexo根目录的source文件夹里创建CNAME文件，不带任何后缀，里面添加你的域名信息，如：sidney001.top。实践证明用www.sidney001.top和sidney001.top访问都是可以的。重新清理hexo,并发布即可用新的域名访问。</del></p>\n<p>在阿里云管理控制台中,选择中刚刚购买的域名,点击解析按钮<br>这时会提醒你选择解析到阿里云主机,或者其他主机,这时需要将你在GitHub上创建的GitHub Pages的域名 xxx.github.io进行查询,得到一个IP地址。</p>\n<p>从ping指令得到一个IP地址 151.101.100.133, 将这个IP地址记录下来<br>进入万网【域名控制台】》【域名解析】标签,选择【解析设置】,<br>点击【添加设置】,添加一个记录类型为A,主机记录为www,解析线路默认,记录值为151.101.100.133的记录<br>点击【添加设置】,再添加一个记录类型为A,主机记录为@,解析线路默认,记录值为151.101.100.133的记录。</p>\n<h3 id=\"Github-解析\"><a href=\"#Github-解析\" class=\"headerlink\" title=\"Github 解析\"></a>Github 解析</h3><p>在GitHub的xxx.github.io项目,进入【Settings】标签页,在【Custom domain】功能中,将刚刚申请的域名写进去。</p>\n<p>GitHub设置完成,等几分钟,在浏览器输入刚刚购买的域名,就可以看到刚刚GitHub上的网站了!</p>\n<h1 id=\"结尾\"><a href=\"#结尾\" class=\"headerlink\" title=\"结尾\"></a>结尾</h1><p>在网上看了很多资料，总结了很多资料，好累(-.-)</p>"},{"title":"Hello World","date":"2016-11-01T12:10:33.000Z","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\ndate: 2016-11-01 20:10:33 \n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","slug":"hello-world","published":1,"updated":"2017-04-03T08:01:08.272Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj23iflzc000dgolameq12kl8","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"external\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"external\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"external\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"external\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"external\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo server</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"external\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo generate</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"external\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo deploy</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"external\">Deployment</a></p>\n","excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo server</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo generate</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo deploy</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\">Deployment</a></p>\n"}],"PostAsset":[{"_id":"source/_posts/Hexo写作技巧(长期更新)/阅读全文.png","post":"cj23iflyr0001gola55jld4lp","slug":"阅读全文.png","modified":1,"renderable":1}],"PostCategory":[{"post_id":"cj23iflyr0001gola55jld4lp","category_id":"cj23iflyx0004golax4zxxh54","_id":"cj23iflzb000cgola16oh3he8"},{"post_id":"cj23iflza000bgolal0mes7dt","category_id":"cj23iflyx0004golax4zxxh54","_id":"cj23iflzg000hgola04evjmb2"},{"post_id":"cj23iflyw0003gola7ydzv7dh","category_id":"cj23iflyx0004golax4zxxh54","_id":"cj23iflzh000lgola63mj0ml2"},{"post_id":"cj23iflz50008gola6qtrqmvu","category_id":"cj23iflzh000mgola8blfr4d4","_id":"cj23iflzj000sgola3vns455x"},{"post_id":"cj23iflz10006gola7laq0nhx","category_id":"cj23iflzd000egolahmq8zfc6","_id":"cj23iflzl000wgola3zvnq29w"},{"post_id":"cj23iflz10006gola7laq0nhx","category_id":"cj23iflzi000qgolajumua9yx","_id":"cj23iflzm000zgolad7xtjegx"},{"post_id":"cj23iflz30007golakkux4flq","category_id":"cj23iflzd000egolahmq8zfc6","_id":"cj23iflzm0010golan2ka0yqa"},{"post_id":"cj23iflz30007golakkux4flq","category_id":"cj23iflzi000qgolajumua9yx","_id":"cj23iflzn0012golah6r53soi"}],"PostTag":[{"post_id":"cj23iflyr0001gola55jld4lp","tag_id":"cj23iflz00005golap8lp8cpw","_id":"cj23iflzf000ggola3oc55kb3"},{"post_id":"cj23iflyr0001gola55jld4lp","tag_id":"cj23iflz8000agoladoulukbh","_id":"cj23iflzg000igola94r8fxvn"},{"post_id":"cj23iflyw0003gola7ydzv7dh","tag_id":"cj23iflz00005golap8lp8cpw","_id":"cj23iflzi000ogola3v2f321m"},{"post_id":"cj23iflyw0003gola7ydzv7dh","tag_id":"cj23iflz8000agoladoulukbh","_id":"cj23iflzi000pgolaik2lbavm"},{"post_id":"cj23iflz10006gola7laq0nhx","tag_id":"cj23iflzh000ngolahe6vfyvd","_id":"cj23iflzk000vgolalz0u7qt5"},{"post_id":"cj23iflz10006gola7laq0nhx","tag_id":"cj23iflzj000rgola8vyr1hsw","_id":"cj23iflzl000xgolafs1r54h9"},{"post_id":"cj23iflz30007golakkux4flq","tag_id":"cj23iflzh000ngolahe6vfyvd","_id":"cj23iflzn0013gola18ia3j5e"},{"post_id":"cj23iflz30007golakkux4flq","tag_id":"cj23iflzj000rgola8vyr1hsw","_id":"cj23iflzn0014golaf645vbln"},{"post_id":"cj23iflz50008gola6qtrqmvu","tag_id":"cj23iflzm0011golawepm2mk7","_id":"cj23iflzo0016golazndv6k25"},{"post_id":"cj23iflza000bgolal0mes7dt","tag_id":"cj23iflz00005golap8lp8cpw","_id":"cj23iflzo0017gola8vexasec"},{"post_id":"cj23iflza000bgolal0mes7dt","tag_id":"cj23iflzn0015golahwq00jnv","_id":"cj23iflzo0018golaiip5s8j4"},{"post_id":"cj23iflza000bgolal0mes7dt","tag_id":"cj23iflz8000agoladoulukbh","_id":"cj23iflzp0019golai61pv8kn"}],"Tag":[{"name":"hexo","_id":"cj23iflz00005golap8lp8cpw"},{"name":"blog","_id":"cj23iflz8000agoladoulukbh"},{"name":"C++","_id":"cj23iflzh000ngolahe6vfyvd"},{"name":"Python","_id":"cj23iflzj000rgola8vyr1hsw"},{"name":"markdown","_id":"cj23iflzm0011golawepm2mk7"},{"name":"github","_id":"cj23iflzn0015golahwq00jnv"}]}}